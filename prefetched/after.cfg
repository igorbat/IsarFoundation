[multiplayer]
	description="Your units are copied to enemy part of the map each two turns.

Copies get stronger every turn.
Survive enemy waves longer than your opponent!
"
	experience_modifier=100
	id="afterlife_survival"
	map_data="Aa, Ai, Gll, Gll, Gll^Emf, Gg, Aa, Gll, Xv, Gll, Aa, Gg, Gll^Emf, Gll, Gll, Ai, Aa
Aa, Wwf, Gll, 2 Gll, Gll, Gll, Gll, Aa, Xv, Aa, Gll, Gll, Gll, 4 Gll, Gll, Wwf, Aa
Gll, Wwf, Wwf, Gll, Gll, Gll, Gll, Gll, Xv, Gll, Gll, Gll, Gll, Gll, Wwf, Wwf, Gll
Wwf, Gll, Gll, Wwf, Wwf^Bsb|, Wwf, Wwf, Gll, Xv, Gll, Wwf, Wwf, Wwf^Bsb|, Wwf, Gll, Gll, Wwf
Gll, Wwf, Wwf^Bsb/, Gll, Gll, Gll, Wwf, Gll, Xv, Gll, Wwf, Gll, Gll, Gll, Wwf^Bsb\, Wwf, Gll
Gd, Gll, Wwf, Gd, Gd, Gll, Wwf, Gll, Xv, Gll, Wwf, Gll, Gd, Gd, Wwf, Gll, Gd
Gd, Gd, Wwf, Hhd^Fp, Gd, Gd, Wwf, Gll, Xv, Gll, Wwf, Gd, Gd, Hhd^Fp, Wwf, Gd, Gd
Gd, Mm, Gs^Vh, Gll^Fp, Wwf, Wwf, Gd, Gd, Xv, Gd, Gd, Wwf, Wwf, Gll^Fp, Gs^Vh, Mm, Gd
Gd, Hhd, Wwf, Wwf, Gd, Hhd, Gs, Gll^Fp, Xv, Gll^Fp, Gs, Hhd, Gd, Wwf, Wwf, Hhd, Gd
Gs, Dd^Do, Wwf, Gll^Fp, Hh, Gs, Gs^Vh, Gs, Xv, Gs, Gs^Vh, Gs, Hh, Gll^Fp, Wwf, Dd^Do, Gs
Gs, Gs, Gs^Fms, Wwf, Gs, Gs, Gs, Hh, Xv, Hh, Gs, Gs, Gs, Wwf, Gs^Fms, Gs, Gs
Gs, Gs^Vh, Gs, Wwf, Wwf, Hh, Gll^Fp, Gs, Xv, Gs, Gll^Fp, Hh, Wwf, Wwf, Gs, Gs^Vh, Gs
Gg, Gg, Gll^Ftr, Gs, Gg, Wwf, Hh, Dd^Do, Xv, Dd^Do, Hh, Wwf, Gg, Gs, Gll^Ftr, Gg, Gg
Gs^Ft, Gg, Gg, Ch, 1 Kh, Ch, Gg, Gg, Xv, Gg, Gg, Ch, 3 Kh, Ch, Gg, Gg, Gs^Ft
Gg, Dd^Ftd, Gg, Gll^Ftr, Gg, Gs^Ft, Gg, Gs^Ft, Xv, Gs^Ft, Gg, Gs^Ft, Gg, Gll^Ftr, Gg, Dd^Ftd, Gg
"
	name="Afterlife"
	random_start_time=yes
	turns=-1
	[event]
		first_time_only=no
		name="preload"
		[set_variable]
			name="afterlife_about_header"
			value="Your units are copied to enemy part of the map each two turns.

Copies get stronger every turn.
Survive enemy waves longer than your opponent!
"
		[/set_variable]
	[/event]
	[event]
		name="preload"
		[lua]
			code="-- advertisement

local wesnoth = wesnoth
local string = string
local tostring = tostring
local wml = wml
local on_event = wesnoth.require(""lua/on_event.lua"")
local T = wesnoth.require(""lua/helper.lua"").set_wml_tag_metatable {}

local addon_name = tostring((...).name)
local addon_dir = tostring((...).dir)
local addon_about = tostring((...).about)
local addon_icon = tostring((...).icon)
local addon_host_version = tostring((...).version)
addon_icon = string.gsub(addon_icon, ""\n"", """") .. ""~SCALE_INTO(144,144)""

wesnoth.wml_actions.set_menu_item {
	id = ""about_"" .. addon_dir,
	description = ""About: "" .. addon_name,
	synced = false,
	T.command {
		T.message {
			caption = addon_name .. "" v"" .. addon_host_version,
			message = addon_about,
			image = addon_icon
		}
	}
}

local function show_message(text)
	wesnoth.wml_actions.message {
		caption = addon_name,
		message = text,
		image = addon_icon,
	}
end

local filename = ""~add-ons/"" .. addon_dir .. ""/target/version.txt""
local my_version = wesnoth.have_file(filename) and wesnoth.read_file(filename) or ""0.0.0""

local highest_ver_key = ""addon_"" .. addon_dir .. ""_highest""
wml.variables[highest_ver_key] = my_version

on_event(""side turn 1"", function()
	local side_version = wesnoth.synchronize_choice(function() return { v = my_version } end).v
	if rawget(_G, ""print_as_json"") then _G.print_as_json(""addon"", addon_name, wesnoth.current.side, side_version) end

	if wesnoth.compare_versions(side_version, "">"", wml.variables[highest_ver_key]) then
		wml.variables[highest_ver_key] = side_version
	end
end)

if my_version == ""0.0.0"" then
	local text = ""This game uses "" .. addon_name .. "" add-on. ""
		.. ""\n""
		.. ""If you'll like it, feel free to install it from add-ons server.""
		.. ""\n\n""
		.. ""======================\n\n""
		.. addon_about
	show_message(text)
	return
end

on_event(""turn 2"", function()
	if my_version == wml.variables[highest_ver_key] then
		return
	end

	local advertisement = ""ðŸ ‰ðŸ ‰ðŸ ‰ Please upgrade your "" .. addon_name .. "" add-on ðŸ ‰ðŸ ‰ðŸ ‰""
		.. ""\n""
		.. my_version .. "" -> "" .. wml.variables[highest_ver_key]
		.. ""  (you may do that after the game)\n\n""
	show_message(advertisement)
end)


-- "
			[args]
				about="Afterlife -- survival and race maps.

Your units are copied to enemy part of the map to be controlled by AI.
"
				dir="afterlife_scenario"
				icon="misc/blank-hex.png~BLIT(units/human-loyalists/spearman.png~CROP(20,0,31,72)~FL())~BLIT(units/human-loyalists/spearman.png~CROP(20,0,31,72)~GS(),36,0)
"
				name="Afterlife survival"
				version="1.8.1"
			[/args]
		[/lua]
	[/event]
	[time]
		blue=0
		green=-15
		id="dawn"
		image="misc/time-schedules/default/schedule-dawn.png"
#textdomain wesnoth-help
		name=_"Dawn"
		red=-25
		sound="ambient/morning.ogg"
	[/time]
	[time]
		id="morning"
		image="misc/time-schedules/default/schedule-morning.png"
		lawful_bonus=25
		name=_"Morning"
	[/time]
	[time]
		id="afternoon"
		image="misc/time-schedules/default/schedule-afternoon.png"
		lawful_bonus=25
		name=_"Afternoon"
	[/time]
	[time]
		blue=-35
		green=-20
		id="dusk"
		image="misc/time-schedules/default/schedule-dusk.png"
		name=_"Dusk"
		red=10
		sound="ambient/night.ogg"
	[/time]
	[time]
		blue=-13
		green=-45
		id="first_watch"
		image="misc/time-schedules/default/schedule-firstwatch.png"
		lawful_bonus=-25
		name=_"First Watch"
		red=-75
	[/time]
	[time]
		blue=-13
		green=-45
		id="second_watch"
		image="misc/time-schedules/default/schedule-secondwatch.png"
		lawful_bonus=-25
		name=_"Second Watch"
		red=-75
	[/time]
	[music]
		ms_before=12000
		name="knolls.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="wanderer.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="battle.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="transience.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_king_is_dead.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="knalgan_theme.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_city_falls.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="nunc_dimittis.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="revelation.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="loyalists.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="breaking_the_chains.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="elvish-theme.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="legends_of_the_north.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="traveling_minstrels.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="underground.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="vengeful.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="frantic.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_dangerous_symphony.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="heroes_rite.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="suspense.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_deep_path.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="siege_of_laurelmor.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="casualties_of_war.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="silvan_sanctuary.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="battle-epic.ogg"
	[/music]
	[event]
		name="prestart"
		[music]
			ms_before=12000
			name="knolls.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="wanderer.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="battle.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="transience.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_king_is_dead.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="knalgan_theme.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_city_falls.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="nunc_dimittis.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="revelation.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="loyalists.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="breaking_the_chains.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="elvish-theme.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="legends_of_the_north.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="traveling_minstrels.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="underground.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="vengeful.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="frantic.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_dangerous_symphony.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="heroes_rite.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="suspense.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_deep_path.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="siege_of_laurelmor.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="casualties_of_war.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="silvan_sanctuary.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="battle-epic.ogg"
		[/music]
	[/event]
	[event]
		name="preload"
		[lua]
			code="-- json_format

-- wesnoth.dofile(""~add-ons/afterlife_scenario/lua/json_format.lua"")

local next = next
local print = print
local tostring = tostring
local type = type
local gsub = string.gsub
local table = table

local delete_chars = string.char(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31) -- https://www.ietf.org/rfc/rfc4627.txt
local delete_regexp = ""["" .. delete_chars .. ""]""

-- escaping takes 3/4 of the time, but we can't avoid it...
local function escape(str)
	str = gsub(str, delete_regexp, """")
	str = gsub(str, '\\', '\\\\')
	return gsub(str, '""', '\\""')
end

local function print_table_key(obj, buffer)
	local _type = type(obj)
	if _type == ""string"" then
		buffer[#buffer + 1] = escape(obj)
	elseif _type == ""number"" then
		buffer[#buffer + 1] = obj
	elseif _type == ""boolean"" then
		buffer[#buffer + 1] = tostring(obj)
	else
		buffer[#buffer + 1] = '???' .. _type .. '???'
	end
end

local function format_any_value(obj, buffer)
	local _type = type(obj)
	if _type == ""table"" then
		buffer[#buffer + 1] = '{'
		buffer[#buffer + 1] = '""' -- needs to be separate for empty tables {}
		for key, value in next, obj, nil do
			print_table_key(key, buffer)
			buffer[#buffer + 1] = '"":'
			format_any_value(value, buffer)
			buffer[#buffer + 1] = ',""'
		end
		buffer[#buffer] = '}' -- note the overwrite
	elseif _type == ""string"" then
		buffer[#buffer + 1] = '""' .. escape(obj) .. '""'
	elseif _type == ""boolean"" or _type == ""number"" then
		buffer[#buffer + 1] = tostring(obj)
	elseif _type == ""userdata"" then
		buffer[#buffer + 1] = '""' .. escape(tostring(obj)) .. '""'
	else
		buffer[#buffer + 1] = '""???' .. _type .. '???""'
	end
end

local function _format_as_json(obj)
	if obj == nil then return ""null"" else
		local buffer = {}
		format_any_value(obj, buffer)
		return table.concat(buffer)
	end
end

local function _print_as_json(...)
	local result = {}
	local n = 1
	for _, v in ipairs({ ... }) do
		result[n] = _format_as_json(v)
		n = n + 1
	end
	print(table.concat(result, ""\t""))
end


format_as_json = _format_as_json
print_as_json = _print_as_json

-- "
		[/lua]
	[/event]
	[event]
		first_time_only=no
		name="preload"
		[lua]
			code="-- utils_afterlife

afterlife = {}
local afterlife = afterlife
local wesnoth = wesnoth
local ipairs = ipairs
local math = math
local string = string
local table = table
local helper = wesnoth.require(""lua/helper.lua"")
local on_event = wesnoth.require(""lua/on_event.lua"")
local T = wesnoth.require(""lua/helper.lua"").set_wml_tag_metatable {}


wesnoth.wml_conditionals = wesnoth.wml_conditionals or {}
wesnoth.wml_conditionals.has_unit = wesnoth.wml_conditionals.has_unit or function(cfg)
	afterlife.temp = false
	wesnoth.wml_actions[""if""] {
		T.have_unit(cfg),
		T[""then""] { T.lua { code = ""afterlife.temp = true"" } }
	}
	return afterlife.temp
end


local function unit_wml_copy(unit_userdata, x, y)
	wesnoth.wml_actions.store_unit {
		T.filter { id = unit_userdata.id },
		variable = ""afterlife_unit"",
	}
	local unit_var = wesnoth.get_variable(""afterlife_unit"")
	local id = ""afterlife_""
		.. helper.rand(""0..1000000000"")
		.. helper.rand(""0..1000000000"")
		.. helper.rand(""0..1000000000"")
	unit_var.id = id
	unit_var.underlying_id = id
	unit_var.canrecruit = false
	unit_var.x = x
	unit_var.y = y
	wesnoth.set_variable(""afterlife_unit"", unit_var)
	wesnoth.wml_actions.unstore_unit {
		variable = ""afterlife_unit"",
	}
	wesnoth.set_variable(""afterlife_unit"", nil)
	return id
end


local function copy_unit(unit_original, to_pos, to_side, strength_percent)
	if to_pos == nil then return end
	if unit_original.type == ""Fog Clearer"" then return end
	local from_side = unit_original.side
	local new_id = unit_wml_copy(unit_original, to_pos.x, to_pos.y)
	local unit = wesnoth.get_units { id = new_id }[1]
	unit.side = to_side
	unit.status.poisoned = false
	unit.status.slowed = false
	unit.variables.afterlife_fresh_copy = true
	unit.moves = unit.max_moves
	wesnoth.add_modification(unit, ""object"", {
		id = ""afterlife_grayscale"",
		T.effect { apply_to = ""image_mod"", add=""GS()"" },
		T.effect { apply_to = ""zoc"", value = false },
	})
	unit.status.petrified = false
	unit.status.invulnerable = true

	local increase_percent = strength_percent - 100
	local ability = T.name_only {
		name = ""copy"" .. strength_percent ..  ""%"",
		description = strength_percent .. ""% hitpoints, ""
			.. strength_percent .. ""% damage, ""
			.. ""unit copied from side "" .. from_side
	}
	wesnoth.add_modification(unit, ""object"", {
		T.effect { apply_to = ""attack"", increase_damage = increase_percent .. ""%"" },
		T.effect { apply_to = ""hitpoints"", increase_total = increase_percent .. ""%"" },
		T.effect { apply_to = ""new_ability"", T.abilities { ability } },
	})
	unit.hitpoints = unit.max_hitpoints
	wesnoth.set_village_owner(to_pos.x, to_pos.y, to_side, false)
end


local function unpetrify_units()
	local status_filter = ""invulnerable""
	local filtered_units = wesnoth.get_units { side = wesnoth.current.side, status = status_filter }
	for _, unit in ipairs(filtered_units) do
		if unit.variables.afterlife_fresh_copy then
			unit.status.petrified = false
			unit.status.invulnerable = false
			unit.variables.afterlife_fresh_copy = nil
			wesnoth.wml_actions.remove_object {
				id = unit.id,
				object_id = ""afterlife_grayscale"",
			}
			local img = string.gsub(unit.image_mods, ""GS%(%)$"", ""NOP()"", 1)
			wesnoth.add_modification(unit, ""object"", {
				T.effect { apply_to = ""image_mod"", replace = img },
			})
		end
	end
end


local width, height, border = wesnoth.get_map_size()
local half = (width - 1) / 2
local left_edge = border
local left_center = half + border - 1
local right_center = half + border + 1
local right_edge = border + width - 1

local terrain_base_probabilities = {
	[""Gs""] = 4, -- grass
	[""Gd""] = 4, -- grass
	[""Gg""] = 3, -- grass
	[""Wwf""] = 28 , -- ford
	[""Gs^Fms""] = 2, -- forest
	[""Gll^Fp""] = 2, -- forest
	[""Mm""] = 1, -- mountain
	[""Ai""] = 1, -- ice
	[""Hh""] = 2, -- hill
	[""Hhd""] = 2, -- dry hill
	[""Uu^Uf""] = 2, -- mushrooms
	[""Dd^Do""] = 1, -- oasis
	[""Ss""] = 1, -- swamp
	[""Gs^Vh""] = 2, -- village
}
local terrain_variability_multiplier = 1 -- how variable terrain will be
local terrain_iterator = {}
local terrain_total = 0
local function set_probability(terrain_index, value)
	wesnoth.set_variable(""afterlife_terrain_prob_"" .. terrain_index, value)
end
local function get_probability(terrain_index)
	return wesnoth.get_variable(""afterlife_terrain_prob_"" .. terrain_index)
end

for terr, value in pairs(terrain_base_probabilities) do
	-- We will need to sort this later because `pairs` is an unordered (OOS-unsafe) iterator
	terrain_total = terrain_total + value
	terrain_iterator[#terrain_iterator + 1] = terr
end
table.sort(terrain_iterator)
for idx, terr in ipairs(terrain_iterator) do
	if get_probability(idx) == nil then
		local base = terrain_base_probabilities[terr]
		set_probability(idx, base * terrain_variability_multiplier)
	end
end

local function random_terrain()
	local offset = helper.rand(""1.."" .. terrain_total * terrain_variability_multiplier)
	for idx, terrain in ipairs(terrain_iterator) do
		offset = offset - get_probability(idx)
		if offset <= 0 then
			-- Now that this terrain is chosen, decrease the chosen terr probability by total,
			-- and add a distributed base to all terrains
			set_probability(idx, get_probability(idx) - terrain_total)
			for small_idx, small_terrain in ipairs(terrain_iterator) do
				local base = terrain_base_probabilities[small_terrain]
				set_probability(small_idx, get_probability(small_idx) + base)
			end
			return terrain
		end
	end
	return ""Aa^Ecf"" -- snow with fire (to see the error)
end


function afterlife.scroll_terrain_down()
	local castle_length = math.ceil(width / 6)
	local scrolls = wesnoth.get_variable(""afterlife_scrolls"") or 0
	wesnoth.set_variable(""afterlife_scrolls"", scrolls + 1)

	for y = height - 1, border, -1 do
		for x = left_edge, right_edge do
			local upper_terrain = wesnoth.get_terrain(x, y - 1)
			wesnoth.set_terrain(x, y, upper_terrain)
			wesnoth.set_village_owner(x, y, wesnoth.get_village_owner(x, y - 1), false)
		end
	end
	local y = border - 1
	for x = left_edge, left_center do
		local rem = scrolls % (castle_length * 4 - 2)
		local terrain
		if x == left_center and rem >= castle_length * 2 + 1 and rem <= castle_length * 3 then
			terrain = ""Kh""
		elseif x == left_edge and rem >= 2 and rem <= castle_length + 1 then
			terrain = ""Kh""
		else
			terrain = random_terrain()
		end
		wesnoth.set_terrain(x, y, terrain)
		wesnoth.set_terrain(width - x + 1, y, terrain)
	end
end

function afterlife.scroll_units_down()
	for _, unit in ipairs(wesnoth.get_units { y = height }) do
		wesnoth.wml_actions.kill {
			id = unit.id,
			fire_event = true,
			animate = true,
		}
	end
	for y = height - 1, 0, -1 do
		for _, unit in ipairs(wesnoth.get_units { y = y }) do
			unit.y = unit.y + 1
		end
	end
end

function afterlife.schedule_scrolling_down(frequency)
	on_event(""start"", function()
		for _ = height, 0, -1 do
			afterlife.scroll_terrain_down()
		end
		wesnoth.wml_actions.redraw {}
	end)
	on_event(""side turn end"", function()
		local micro_turn = (wesnoth.current.turn - 1) * #wesnoth.sides + wesnoth.current.side - 4
		if micro_turn % frequency == 0 then
			afterlife.scroll_units_down()
			afterlife.scroll_terrain_down()
			wesnoth.wml_actions.redraw {}
		end
	end)
end


function afterlife.find_vacant(unit, y_min, honor_edge, flip)
	y_min = math.max(border, y_min)
	local x_start = unit.x < right_center and right_center or left_center
	local x_end = unit.x < right_center and right_edge or left_edge
	if flip then x_start, x_end = x_end, x_start end
	local x_step = (x_end - x_start) / math.abs(x_end - x_start)
	for y = y_min, height do
		for x = x_start, x_end, x_step do
			local is_edge = honor_edge and y == y_min and x == x_start
			if wesnoth.wml_conditionals.has_unit { x = x, y = y } == false
				and wesnoth.get_terrain(x, y) ~= ""Xv""
				and not is_edge then
				return { x = x, y = y }
			end
		end
	end
end


function afterlife.kill_ai_leaders()
	for _, side in ipairs(wesnoth.sides) do
		if side.__cfg.allow_player == false then
			wesnoth.wml_actions.kill {
				canrecruit = true,
				side = side.side,
				fire_event = false,
				animate = false,
			}
		end
	end
end


local function endlevel_team(winner_team)
	local i_am_winner = false
	for _, side in ipairs(wesnoth.sides) do
		if side.team_name ~= winner_team and side.__cfg.allow_player == true then
			wesnoth.wml_actions.kill {
				side = side.side,
			}
		end
		if side.team_name == winner_team and side.__cfg.allow_player == true and side.is_local then
			i_am_winner = true
		end
	end

	wesnoth.wml_actions.endlevel {
		result = i_am_winner and ""victory"" or ""defeat""
	}
end


print(""active mods:"", wesnoth.game_config.mp_settings.active_mods)


afterlife.endlevel_team = endlevel_team
afterlife.copy_unit = copy_unit
afterlife.unpetrify_units = unpetrify_units

-- "
		[/lua]
		[lua]
			code="-- afterlife/main_defense

local wesnoth = wesnoth
local afterlife = afterlife
local ipairs = ipairs
local math = math
local string = string
local wml = wml
local on_event = wesnoth.require(""lua/on_event.lua"")


local is_team = #wesnoth.sides == 6
local copy_strength_start = is_team and 26 or 32 -- point of no return is about 50%
local copy_strength_increase = 2
local teams = {}
for _, side in ipairs(wesnoth.sides) do
	local team_id = teams[side.team_name] or (#teams + 1);
	teams[side.team_name] = team_id;
	local team = teams[team_id] or { enemy = 3 - team_id, humans = {} };
	teams[team_id] = team
	local is_alive = wml.variables[""afterlife_alive_"" .. side.side] or #wesnoth.get_units { side = side.side } > 0
	wml.variables[""afterlife_alive_"" .. side.side] = is_alive
	if side.__cfg.allow_player == false then
		team.ai = side.side
	elseif is_alive then
		team.humans[#team.humans + 1] = side.side
	end
end
-- print_as_json(teams)


on_event(""start"", function()
	afterlife.kill_ai_leaders()
	for _, side in ipairs(wesnoth.sides) do
		side.village_support = side.village_support + 2
	end
end)

local ai_starting_location_y = wesnoth.get_starting_location(#wesnoth.sides)[2]
local function copy_units(from_side, to_side)
	for _, unit_original in ipairs(wesnoth.get_units { side = from_side }) do
		local percent = copy_strength_start + wesnoth.current.turn * copy_strength_increase
		local to_pos = afterlife.find_vacant(unit_original, ai_starting_location_y, true, is_team)
		if to_pos == nil then
			wesnoth.wml_actions.message {
				speaker = ""narrator"",
				message = ""No free space to place a copy"",
			}
			afterlife.endlevel_team(from_side, wesnoth.sides[from_side].team_name)
			break
		else
			afterlife.copy_unit(unit_original, to_pos, to_side, percent)
		end
	end
end

on_event(""turn refresh"", function()
	local wave_length = wesnoth.get_variable(""afterlife_wave_length"") or 2
	if (wesnoth.current.turn - 1) % wave_length == 0 then
		if wesnoth.current.side == 1 then
			copy_units(teams[1].humans[wesnoth.current.turn % #teams[1].humans + 1], teams[1].ai)
			copy_units(teams[2].humans[wesnoth.current.turn % #teams[2].humans + 1], teams[2].ai)
		end
		if wesnoth.sides[wesnoth.current.side].__cfg.allow_player == false then
			afterlife.unpetrify_units()
		end
	end
	-- print(""turn"", wesnoth.current.turn, ""side"", wesnoth.current.side, ""div"", (wesnoth.current.turn - 2) % wave_length)
	if wave_length > 1 then
		local next_wave_turn = wesnoth.current.turn
			- (wesnoth.current.turn - 2) % wave_length
			+ wave_length - 1
		wesnoth.wml_actions.label {
			x = math.ceil(wesnoth.get_map_size() / 2),
			y = 2,
			text = string.format(""<span color='#FFFFFF'>Next wave:\n    turn %s</span>"", next_wave_turn)
		}
	end
end)

on_event(""side turn end"", function()
	for _, unit in ipairs(wesnoth.get_units { canrecruit = true, side = wesnoth.current.side }) do
		unit.status.uncovered = true
	end
end)


-- "
		[/lua]
		[objectives]
			note="$afterlife_about_header|

Contacts
* Forum: https://forums.wesnoth.org/viewtopic.php?f=8&amp;t=47827
* Source code, issue tracker: https://github.com/vgaming/afterlife
* vasili or vasya: my name on wesnoth :)
* vn971 on IRC.freenode.net (I often visit #wesnoth-umc-dev)


version 1.8.1
"
			[objective]
				condition="win"
#textdomain wesnoth
				description=_"Death of enemy Leader"
			[/objective]
			[objective]
				condition="lose"
				description=_"Death of your Leader"
			[/objective]
		[/objectives]
	[/event]
	[side]
		controller="human"
		fog=false
		gold=75
		shroud=false
		team_lock=true
		team_name="West"
	[/side]
	[side]
		allow_player=false
		controller="ai"
		defeat_condition="always"
		fog=false
		shroud=false
		team_lock=true
		team_name="East"
		[ai]
			aggression=0.995
			caution=0.005
			grouping=no
		[/ai]
	[/side]
	[side]
		controller="human"
		fog=false
		gold=75
		shroud=false
		team_lock=true
		team_name="East"
	[/side]
	[side]
		allow_player=false
		controller="ai"
		defeat_condition="always"
		fog=false
		shroud=false
		team_lock=true
		team_name="West"
		[ai]
			aggression=0.995
			caution=0.005
			grouping=no
		[/ai]
	[/side]
[/multiplayer]
[multiplayer]
	description="Lava comes from below -- walk forward to survive!
"
	experience_modifier=100
	id="afterlife_lava"
	map_data="Gll, Kh, Gll, Gll, Gll^Emf, Gg, Aa, Gll, Xv, Gll, Aa, Gg, Gll^Emf, Gll, Gll, Kh, Gll
Gll, Gd, Gll, Gll, Gll, Gll, Gll, Aa, Xv, Aa, Gll, Gll, Gll, Gll, Gll, Gd, Gll
Gll, Gd, Wwf, Gll, Gll, Gll, 2 Gll, Gll, Xv, Gll, 4 Gll, Gll, Gll, Gll, Wwf, Gd, Gll
Wwf, Gd, Wwf, Wwf, Wwf^Bsb|, Wwf, Wwf, Gll, Xv, Gll, Wwf, Wwf, Wwf^Bsb|, Wwf, Wwf, Gd, Wwf
Gll, Gd, Wwf^Bsb/, Gll, Gll, Gll, Wwf, Kh, Xv, Kh, Wwf, Gll, Gll, Gll, Wwf^Bsb\, Gd, Gll
Gd, Gd, Wwf, Gd, Gd, Gll, Wwf, Kh, Xv, Kh, Wwf, Gll, Gd, Gd, Wwf, Gd, Gd
Gd, Gd, Wwf, Hhd^Fp, Gd, Gd, Wwf, Kh, Xv, Kh, Wwf, Gd, Gd, Hhd^Fp, Wwf, Gd, Gd
Gd, Mm, Gs^Vh, Gll^Fp, Wwf, Wwf, Gd, Gd, Xv, Gd, Gd, Wwf, Wwf, Gll^Fp, Gs^Vh, Mm, Gd
Gd, Dd^Do, Wwf, Wwf, Gd, Hhd, Gs, Gll^Fp, Xv, Gll^Fp, Gs, Hhd, Gd, Wwf, Wwf, Dd^Do, Gd
Gs, Gd, Wwf, Gll^Fp, Hh, Gs, Gs^Vh, Gs, Xv, Gs, Gs^Vh, Gs, Hh, Gll^Fp, Wwf, Gd, Gs
Gs, 1 Kh, Gs^Fms, Wwf, Gs, Gs, Gs, Hh, Xv, Hh, Gs, Gs, Gs, Wwf, Gs^Fms, 3 Kh, Gs
Gs, Kh, Gs, Wwf, Wwf, Hh, Gll^Fp, Gs, Xv, Gs, Gll^Fp, Hh, Wwf, Wwf, Gs, Kh, Gs
Xv, Kh, Gs, Gs, Gs, Wwf, Wwf, Gg^Ve, Xv, Gg^Ve, Wwf, Wwf, Gs, Gs, Gs, Kh, Xv
Ql, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Ql, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Ql
Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Xv, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql
"
	name="Afterlife Lava (small)"
	random_start_time=yes
	turns=-1
	[event]
		first_time_only=no
		name="preload"
		[set_variable]
			name="afterlife_about_header"
			value="Lava comes from below -- walk forward to survive!
"
		[/set_variable]
	[/event]
	[event]
		name="preload"
		[lua]
			code="-- advertisement

local wesnoth = wesnoth
local string = string
local tostring = tostring
local wml = wml
local on_event = wesnoth.require(""lua/on_event.lua"")
local T = wesnoth.require(""lua/helper.lua"").set_wml_tag_metatable {}

local addon_name = tostring((...).name)
local addon_dir = tostring((...).dir)
local addon_about = tostring((...).about)
local addon_icon = tostring((...).icon)
local addon_host_version = tostring((...).version)
addon_icon = string.gsub(addon_icon, ""\n"", """") .. ""~SCALE_INTO(144,144)""

wesnoth.wml_actions.set_menu_item {
	id = ""about_"" .. addon_dir,
	description = ""About: "" .. addon_name,
	synced = false,
	T.command {
		T.message {
			caption = addon_name .. "" v"" .. addon_host_version,
			message = addon_about,
			image = addon_icon
		}
	}
}

local function show_message(text)
	wesnoth.wml_actions.message {
		caption = addon_name,
		message = text,
		image = addon_icon,
	}
end

local filename = ""~add-ons/"" .. addon_dir .. ""/target/version.txt""
local my_version = wesnoth.have_file(filename) and wesnoth.read_file(filename) or ""0.0.0""

local highest_ver_key = ""addon_"" .. addon_dir .. ""_highest""
wml.variables[highest_ver_key] = my_version

on_event(""side turn 1"", function()
	local side_version = wesnoth.synchronize_choice(function() return { v = my_version } end).v
	if rawget(_G, ""print_as_json"") then _G.print_as_json(""addon"", addon_name, wesnoth.current.side, side_version) end

	if wesnoth.compare_versions(side_version, "">"", wml.variables[highest_ver_key]) then
		wml.variables[highest_ver_key] = side_version
	end
end)

if my_version == ""0.0.0"" then
	local text = ""This game uses "" .. addon_name .. "" add-on. ""
		.. ""\n""
		.. ""If you'll like it, feel free to install it from add-ons server.""
		.. ""\n\n""
		.. ""======================\n\n""
		.. addon_about
	show_message(text)
	return
end

on_event(""turn 2"", function()
	if my_version == wml.variables[highest_ver_key] then
		return
	end

	local advertisement = ""ðŸ ‰ðŸ ‰ðŸ ‰ Please upgrade your "" .. addon_name .. "" add-on ðŸ ‰ðŸ ‰ðŸ ‰""
		.. ""\n""
		.. my_version .. "" -> "" .. wml.variables[highest_ver_key]
		.. ""  (you may do that after the game)\n\n""
	show_message(advertisement)
end)


-- "
			[args]
				about="Afterlife -- survival and race maps.

Your units are copied to enemy part of the map to be controlled by AI.
"
				dir="afterlife_scenario"
				icon="misc/blank-hex.png~BLIT(units/human-loyalists/spearman.png~CROP(20,0,31,72)~FL())~BLIT(units/human-loyalists/spearman.png~CROP(20,0,31,72)~GS(),36,0)
"
				name="Afterlife survival"
				version="1.8.1"
			[/args]
		[/lua]
	[/event]
	[time]
		blue=0
		green=-15
		id="dawn"
		image="misc/time-schedules/default/schedule-dawn.png"
#textdomain wesnoth-help
		name=_"Dawn"
		red=-25
		sound="ambient/morning.ogg"
	[/time]
	[time]
		id="morning"
		image="misc/time-schedules/default/schedule-morning.png"
		lawful_bonus=25
		name=_"Morning"
	[/time]
	[time]
		id="afternoon"
		image="misc/time-schedules/default/schedule-afternoon.png"
		lawful_bonus=25
		name=_"Afternoon"
	[/time]
	[time]
		blue=-35
		green=-20
		id="dusk"
		image="misc/time-schedules/default/schedule-dusk.png"
		name=_"Dusk"
		red=10
		sound="ambient/night.ogg"
	[/time]
	[time]
		blue=-13
		green=-45
		id="first_watch"
		image="misc/time-schedules/default/schedule-firstwatch.png"
		lawful_bonus=-25
		name=_"First Watch"
		red=-75
	[/time]
	[time]
		blue=-13
		green=-45
		id="second_watch"
		image="misc/time-schedules/default/schedule-secondwatch.png"
		lawful_bonus=-25
		name=_"Second Watch"
		red=-75
	[/time]
	[music]
		ms_before=12000
		name="knolls.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="wanderer.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="battle.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="transience.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_king_is_dead.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="knalgan_theme.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_city_falls.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="nunc_dimittis.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="revelation.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="loyalists.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="breaking_the_chains.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="elvish-theme.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="legends_of_the_north.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="traveling_minstrels.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="underground.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="vengeful.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="frantic.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_dangerous_symphony.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="heroes_rite.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="suspense.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_deep_path.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="siege_of_laurelmor.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="casualties_of_war.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="silvan_sanctuary.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="battle-epic.ogg"
	[/music]
	[event]
		name="prestart"
		[music]
			ms_before=12000
			name="knolls.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="wanderer.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="battle.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="transience.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_king_is_dead.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="knalgan_theme.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_city_falls.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="nunc_dimittis.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="revelation.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="loyalists.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="breaking_the_chains.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="elvish-theme.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="legends_of_the_north.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="traveling_minstrels.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="underground.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="vengeful.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="frantic.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_dangerous_symphony.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="heroes_rite.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="suspense.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_deep_path.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="siege_of_laurelmor.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="casualties_of_war.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="silvan_sanctuary.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="battle-epic.ogg"
		[/music]
	[/event]
	[event]
		name="preload"
		[lua]
			code="-- json_format

-- wesnoth.dofile(""~add-ons/afterlife_scenario/lua/json_format.lua"")

local next = next
local print = print
local tostring = tostring
local type = type
local gsub = string.gsub
local table = table

local delete_chars = string.char(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31) -- https://www.ietf.org/rfc/rfc4627.txt
local delete_regexp = ""["" .. delete_chars .. ""]""

-- escaping takes 3/4 of the time, but we can't avoid it...
local function escape(str)
	str = gsub(str, delete_regexp, """")
	str = gsub(str, '\\', '\\\\')
	return gsub(str, '""', '\\""')
end

local function print_table_key(obj, buffer)
	local _type = type(obj)
	if _type == ""string"" then
		buffer[#buffer + 1] = escape(obj)
	elseif _type == ""number"" then
		buffer[#buffer + 1] = obj
	elseif _type == ""boolean"" then
		buffer[#buffer + 1] = tostring(obj)
	else
		buffer[#buffer + 1] = '???' .. _type .. '???'
	end
end

local function format_any_value(obj, buffer)
	local _type = type(obj)
	if _type == ""table"" then
		buffer[#buffer + 1] = '{'
		buffer[#buffer + 1] = '""' -- needs to be separate for empty tables {}
		for key, value in next, obj, nil do
			print_table_key(key, buffer)
			buffer[#buffer + 1] = '"":'
			format_any_value(value, buffer)
			buffer[#buffer + 1] = ',""'
		end
		buffer[#buffer] = '}' -- note the overwrite
	elseif _type == ""string"" then
		buffer[#buffer + 1] = '""' .. escape(obj) .. '""'
	elseif _type == ""boolean"" or _type == ""number"" then
		buffer[#buffer + 1] = tostring(obj)
	elseif _type == ""userdata"" then
		buffer[#buffer + 1] = '""' .. escape(tostring(obj)) .. '""'
	else
		buffer[#buffer + 1] = '""???' .. _type .. '???""'
	end
end

local function _format_as_json(obj)
	if obj == nil then return ""null"" else
		local buffer = {}
		format_any_value(obj, buffer)
		return table.concat(buffer)
	end
end

local function _print_as_json(...)
	local result = {}
	local n = 1
	for _, v in ipairs({ ... }) do
		result[n] = _format_as_json(v)
		n = n + 1
	end
	print(table.concat(result, ""\t""))
end


format_as_json = _format_as_json
print_as_json = _print_as_json

-- "
		[/lua]
	[/event]
	[event]
		first_time_only=no
		name="preload"
		[lua]
			code="-- utils_afterlife

afterlife = {}
local afterlife = afterlife
local wesnoth = wesnoth
local ipairs = ipairs
local math = math
local string = string
local table = table
local helper = wesnoth.require(""lua/helper.lua"")
local on_event = wesnoth.require(""lua/on_event.lua"")
local T = wesnoth.require(""lua/helper.lua"").set_wml_tag_metatable {}


wesnoth.wml_conditionals = wesnoth.wml_conditionals or {}
wesnoth.wml_conditionals.has_unit = wesnoth.wml_conditionals.has_unit or function(cfg)
	afterlife.temp = false
	wesnoth.wml_actions[""if""] {
		T.have_unit(cfg),
		T[""then""] { T.lua { code = ""afterlife.temp = true"" } }
	}
	return afterlife.temp
end


local function unit_wml_copy(unit_userdata, x, y)
	wesnoth.wml_actions.store_unit {
		T.filter { id = unit_userdata.id },
		variable = ""afterlife_unit"",
	}
	local unit_var = wesnoth.get_variable(""afterlife_unit"")
	local id = ""afterlife_""
		.. helper.rand(""0..1000000000"")
		.. helper.rand(""0..1000000000"")
		.. helper.rand(""0..1000000000"")
	unit_var.id = id
	unit_var.underlying_id = id
	unit_var.canrecruit = false
	unit_var.x = x
	unit_var.y = y
	wesnoth.set_variable(""afterlife_unit"", unit_var)
	wesnoth.wml_actions.unstore_unit {
		variable = ""afterlife_unit"",
	}
	wesnoth.set_variable(""afterlife_unit"", nil)
	return id
end


local function copy_unit(unit_original, to_pos, to_side, strength_percent)
	if to_pos == nil then return end
	if unit_original.type == ""Fog Clearer"" then return end
	local from_side = unit_original.side
	local new_id = unit_wml_copy(unit_original, to_pos.x, to_pos.y)
	local unit = wesnoth.get_units { id = new_id }[1]
	unit.side = to_side
	unit.status.poisoned = false
	unit.status.slowed = false
	unit.variables.afterlife_fresh_copy = true
	unit.moves = unit.max_moves
	wesnoth.add_modification(unit, ""object"", {
		id = ""afterlife_grayscale"",
		T.effect { apply_to = ""image_mod"", add=""GS()"" },
		T.effect { apply_to = ""zoc"", value = false },
	})
	unit.status.petrified = false
	unit.status.invulnerable = true

	local increase_percent = strength_percent - 100
	local ability = T.name_only {
		name = ""copy"" .. strength_percent ..  ""%"",
		description = strength_percent .. ""% hitpoints, ""
			.. strength_percent .. ""% damage, ""
			.. ""unit copied from side "" .. from_side
	}
	wesnoth.add_modification(unit, ""object"", {
		T.effect { apply_to = ""attack"", increase_damage = increase_percent .. ""%"" },
		T.effect { apply_to = ""hitpoints"", increase_total = increase_percent .. ""%"" },
		T.effect { apply_to = ""new_ability"", T.abilities { ability } },
	})
	unit.hitpoints = unit.max_hitpoints
	wesnoth.set_village_owner(to_pos.x, to_pos.y, to_side, false)
end


local function unpetrify_units()
	local status_filter = ""invulnerable""
	local filtered_units = wesnoth.get_units { side = wesnoth.current.side, status = status_filter }
	for _, unit in ipairs(filtered_units) do
		if unit.variables.afterlife_fresh_copy then
			unit.status.petrified = false
			unit.status.invulnerable = false
			unit.variables.afterlife_fresh_copy = nil
			wesnoth.wml_actions.remove_object {
				id = unit.id,
				object_id = ""afterlife_grayscale"",
			}
			local img = string.gsub(unit.image_mods, ""GS%(%)$"", ""NOP()"", 1)
			wesnoth.add_modification(unit, ""object"", {
				T.effect { apply_to = ""image_mod"", replace = img },
			})
		end
	end
end


local width, height, border = wesnoth.get_map_size()
local half = (width - 1) / 2
local left_edge = border
local left_center = half + border - 1
local right_center = half + border + 1
local right_edge = border + width - 1

local terrain_base_probabilities = {
	[""Gs""] = 4, -- grass
	[""Gd""] = 4, -- grass
	[""Gg""] = 3, -- grass
	[""Wwf""] = 28 , -- ford
	[""Gs^Fms""] = 2, -- forest
	[""Gll^Fp""] = 2, -- forest
	[""Mm""] = 1, -- mountain
	[""Ai""] = 1, -- ice
	[""Hh""] = 2, -- hill
	[""Hhd""] = 2, -- dry hill
	[""Uu^Uf""] = 2, -- mushrooms
	[""Dd^Do""] = 1, -- oasis
	[""Ss""] = 1, -- swamp
	[""Gs^Vh""] = 2, -- village
}
local terrain_variability_multiplier = 1 -- how variable terrain will be
local terrain_iterator = {}
local terrain_total = 0
local function set_probability(terrain_index, value)
	wesnoth.set_variable(""afterlife_terrain_prob_"" .. terrain_index, value)
end
local function get_probability(terrain_index)
	return wesnoth.get_variable(""afterlife_terrain_prob_"" .. terrain_index)
end

for terr, value in pairs(terrain_base_probabilities) do
	-- We will need to sort this later because `pairs` is an unordered (OOS-unsafe) iterator
	terrain_total = terrain_total + value
	terrain_iterator[#terrain_iterator + 1] = terr
end
table.sort(terrain_iterator)
for idx, terr in ipairs(terrain_iterator) do
	if get_probability(idx) == nil then
		local base = terrain_base_probabilities[terr]
		set_probability(idx, base * terrain_variability_multiplier)
	end
end

local function random_terrain()
	local offset = helper.rand(""1.."" .. terrain_total * terrain_variability_multiplier)
	for idx, terrain in ipairs(terrain_iterator) do
		offset = offset - get_probability(idx)
		if offset <= 0 then
			-- Now that this terrain is chosen, decrease the chosen terr probability by total,
			-- and add a distributed base to all terrains
			set_probability(idx, get_probability(idx) - terrain_total)
			for small_idx, small_terrain in ipairs(terrain_iterator) do
				local base = terrain_base_probabilities[small_terrain]
				set_probability(small_idx, get_probability(small_idx) + base)
			end
			return terrain
		end
	end
	return ""Aa^Ecf"" -- snow with fire (to see the error)
end


function afterlife.scroll_terrain_down()
	local castle_length = math.ceil(width / 6)
	local scrolls = wesnoth.get_variable(""afterlife_scrolls"") or 0
	wesnoth.set_variable(""afterlife_scrolls"", scrolls + 1)

	for y = height - 1, border, -1 do
		for x = left_edge, right_edge do
			local upper_terrain = wesnoth.get_terrain(x, y - 1)
			wesnoth.set_terrain(x, y, upper_terrain)
			wesnoth.set_village_owner(x, y, wesnoth.get_village_owner(x, y - 1), false)
		end
	end
	local y = border - 1
	for x = left_edge, left_center do
		local rem = scrolls % (castle_length * 4 - 2)
		local terrain
		if x == left_center and rem >= castle_length * 2 + 1 and rem <= castle_length * 3 then
			terrain = ""Kh""
		elseif x == left_edge and rem >= 2 and rem <= castle_length + 1 then
			terrain = ""Kh""
		else
			terrain = random_terrain()
		end
		wesnoth.set_terrain(x, y, terrain)
		wesnoth.set_terrain(width - x + 1, y, terrain)
	end
end

function afterlife.scroll_units_down()
	for _, unit in ipairs(wesnoth.get_units { y = height }) do
		wesnoth.wml_actions.kill {
			id = unit.id,
			fire_event = true,
			animate = true,
		}
	end
	for y = height - 1, 0, -1 do
		for _, unit in ipairs(wesnoth.get_units { y = y }) do
			unit.y = unit.y + 1
		end
	end
end

function afterlife.schedule_scrolling_down(frequency)
	on_event(""start"", function()
		for _ = height, 0, -1 do
			afterlife.scroll_terrain_down()
		end
		wesnoth.wml_actions.redraw {}
	end)
	on_event(""side turn end"", function()
		local micro_turn = (wesnoth.current.turn - 1) * #wesnoth.sides + wesnoth.current.side - 4
		if micro_turn % frequency == 0 then
			afterlife.scroll_units_down()
			afterlife.scroll_terrain_down()
			wesnoth.wml_actions.redraw {}
		end
	end)
end


function afterlife.find_vacant(unit, y_min, honor_edge, flip)
	y_min = math.max(border, y_min)
	local x_start = unit.x < right_center and right_center or left_center
	local x_end = unit.x < right_center and right_edge or left_edge
	if flip then x_start, x_end = x_end, x_start end
	local x_step = (x_end - x_start) / math.abs(x_end - x_start)
	for y = y_min, height do
		for x = x_start, x_end, x_step do
			local is_edge = honor_edge and y == y_min and x == x_start
			if wesnoth.wml_conditionals.has_unit { x = x, y = y } == false
				and wesnoth.get_terrain(x, y) ~= ""Xv""
				and not is_edge then
				return { x = x, y = y }
			end
		end
	end
end


function afterlife.kill_ai_leaders()
	for _, side in ipairs(wesnoth.sides) do
		if side.__cfg.allow_player == false then
			wesnoth.wml_actions.kill {
				canrecruit = true,
				side = side.side,
				fire_event = false,
				animate = false,
			}
		end
	end
end


local function endlevel_team(winner_team)
	local i_am_winner = false
	for _, side in ipairs(wesnoth.sides) do
		if side.team_name ~= winner_team and side.__cfg.allow_player == true then
			wesnoth.wml_actions.kill {
				side = side.side,
			}
		end
		if side.team_name == winner_team and side.__cfg.allow_player == true and side.is_local then
			i_am_winner = true
		end
	end

	wesnoth.wml_actions.endlevel {
		result = i_am_winner and ""victory"" or ""defeat""
	}
end


print(""active mods:"", wesnoth.game_config.mp_settings.active_mods)


afterlife.endlevel_team = endlevel_team
afterlife.copy_unit = copy_unit
afterlife.unpetrify_units = unpetrify_units

-- "
		[/lua]
		[lua]
			code="-- afterlife/main_defense

local wesnoth = wesnoth
local afterlife = afterlife
local ipairs = ipairs
local math = math
local string = string
local wml = wml
local on_event = wesnoth.require(""lua/on_event.lua"")


local is_team = #wesnoth.sides == 6
local copy_strength_start = is_team and 26 or 32 -- point of no return is about 50%
local copy_strength_increase = 2
local teams = {}
for _, side in ipairs(wesnoth.sides) do
	local team_id = teams[side.team_name] or (#teams + 1);
	teams[side.team_name] = team_id;
	local team = teams[team_id] or { enemy = 3 - team_id, humans = {} };
	teams[team_id] = team
	local is_alive = wml.variables[""afterlife_alive_"" .. side.side] or #wesnoth.get_units { side = side.side } > 0
	wml.variables[""afterlife_alive_"" .. side.side] = is_alive
	if side.__cfg.allow_player == false then
		team.ai = side.side
	elseif is_alive then
		team.humans[#team.humans + 1] = side.side
	end
end
-- print_as_json(teams)


on_event(""start"", function()
	afterlife.kill_ai_leaders()
	for _, side in ipairs(wesnoth.sides) do
		side.village_support = side.village_support + 2
	end
end)

local ai_starting_location_y = wesnoth.get_starting_location(#wesnoth.sides)[2]
local function copy_units(from_side, to_side)
	for _, unit_original in ipairs(wesnoth.get_units { side = from_side }) do
		local percent = copy_strength_start + wesnoth.current.turn * copy_strength_increase
		local to_pos = afterlife.find_vacant(unit_original, ai_starting_location_y, true, is_team)
		if to_pos == nil then
			wesnoth.wml_actions.message {
				speaker = ""narrator"",
				message = ""No free space to place a copy"",
			}
			afterlife.endlevel_team(from_side, wesnoth.sides[from_side].team_name)
			break
		else
			afterlife.copy_unit(unit_original, to_pos, to_side, percent)
		end
	end
end

on_event(""turn refresh"", function()
	local wave_length = wesnoth.get_variable(""afterlife_wave_length"") or 2
	if (wesnoth.current.turn - 1) % wave_length == 0 then
		if wesnoth.current.side == 1 then
			copy_units(teams[1].humans[wesnoth.current.turn % #teams[1].humans + 1], teams[1].ai)
			copy_units(teams[2].humans[wesnoth.current.turn % #teams[2].humans + 1], teams[2].ai)
		end
		if wesnoth.sides[wesnoth.current.side].__cfg.allow_player == false then
			afterlife.unpetrify_units()
		end
	end
	-- print(""turn"", wesnoth.current.turn, ""side"", wesnoth.current.side, ""div"", (wesnoth.current.turn - 2) % wave_length)
	if wave_length > 1 then
		local next_wave_turn = wesnoth.current.turn
			- (wesnoth.current.turn - 2) % wave_length
			+ wave_length - 1
		wesnoth.wml_actions.label {
			x = math.ceil(wesnoth.get_map_size() / 2),
			y = 2,
			text = string.format(""<span color='#FFFFFF'>Next wave:\n    turn %s</span>"", next_wave_turn)
		}
	end
end)

on_event(""side turn end"", function()
	for _, unit in ipairs(wesnoth.get_units { canrecruit = true, side = wesnoth.current.side }) do
		unit.status.uncovered = true
	end
end)


-- "
		[/lua]
		[objectives]
			note="$afterlife_about_header|

Contacts
* Forum: https://forums.wesnoth.org/viewtopic.php?f=8&amp;t=47827
* Source code, issue tracker: https://github.com/vgaming/afterlife
* vasili or vasya: my name on wesnoth :)
* vn971 on IRC.freenode.net (I often visit #wesnoth-umc-dev)


version 1.8.1
"
			[objective]
				condition="win"
#textdomain wesnoth
				description=_"Death of enemy Leader"
			[/objective]
			[objective]
				condition="lose"
				description=_"Death of your Leader"
			[/objective]
		[/objectives]
	[/event]
	[event]
		first_time_only=no
		name="preload"
		[lua]
			code="
				afterlife.schedule_scrolling_down(8)
				wesnoth.set_variable(""afterlife_wave_length"", 3)
			"
		[/lua]
	[/event]
	[side]
		controller="human"
		fog=false
		gold=75
		shroud=false
		team_lock=true
		team_name="West"
	[/side]
	[side]
		allow_player=false
		controller="ai"
		defeat_condition="always"
		fog=false
		shroud=false
		team_lock=true
		team_name="East"
		[ai]
			aggression=0.995
			caution=0.005
			grouping=no
		[/ai]
	[/side]
	[side]
		controller="human"
		fog=false
		gold=75
		shroud=false
		team_lock=true
		team_name="East"
	[/side]
	[side]
		allow_player=false
		controller="ai"
		defeat_condition="always"
		fog=false
		shroud=false
		team_lock=true
		team_name="West"
		[ai]
			aggression=0.995
			caution=0.005
			grouping=no
		[/ai]
	[/side]
[/multiplayer]
[multiplayer]
	description="Lava comes from below -- walk forward to survive!
"
	experience_modifier=100
	id="afterlife_volcano"
	map_data="Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Xv, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg
Gg, Gg, Aa, Aa, Aa, Gg, Aa, Aa, Aa, Gg, Aa, Aa, Xv, Aa, Aa, Gg, Aa, Aa, Aa, Gg, Aa, Aa, Aa, Gg, Gg
Gg, Aa, Gg, Gg, Gg, Aa, Gg, Gg, Gg, Aa, 2 Gg, Gg, Xv, Gg, 4 Gg, Aa, Gg, Gg, Gg, Aa, Gg, Gg, Gg, Aa, Gg
Gg, Aa, Aa, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Xv, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Gg, Aa, Aa, Gg
Gg, Gg, Gg, Aa, Gll, Kh, Gll, Gll, Gll^Emf, Gg, Aa, Gll, Xv, Gll, Aa, Gg, Gll^Emf, Gll, Gll, Kh, Gll, Aa, Gg, Gg, Gg
Gg, Gg, Aa, Aa, Gll, Gd, Gll, Gll, Gll, Gll, Gll, Aa, Xv, Aa, Gll, Gll, Gll, Gll, Gll, Gd, Gll, Aa, Aa, Gg, Gg
Gg, Aa, Gg, Gg, Gll, Gd, Wwf, Gll, Gll, Gll, Gll, Gll, Xv, Gll, Gll, Gll, Gll, Gll, Wwf, Gd, Gll, Gg, Gg, Aa, Gg
Gg, Aa, Aa, Gg, Wwf, Gd, Wwf, Wwf, Wwf^Bsb|, Wwf, Wwf, Gll, Xv, Gll, Wwf, Wwf, Wwf^Bsb|, Wwf, Wwf, Gd, Wwf, Gg, Aa, Aa, Gg
Gg, Gg, Gg, Aa, Gll, Gd, Wwf^Bsb/, Gll, Gll, Gll, Wwf, Kh, Xv, Kh, Wwf, Gll, Gll, Gll, Wwf^Bsb\, Gd, Gll, Aa, Gg, Gg, Gg
Gg, Gg, Aa, Aa, Gd, Gd, Wwf, Gd, Gd, Gll, Wwf, Kh, Xv, Kh, Wwf, Gll, Gd, Gd, Wwf, Gd, Gd, Aa, Aa, Gg, Gg
Gg, Aa, Gg, Gg, Gd, Gd, Wwf, Hhd^Fp, Gd, Gd, Wwf, Kh, Xv, Kh, Wwf, Gd, Gd, Hhd^Fp, Wwf, Gd, Gd, Gg, Gg, Aa, Gg
Gg, Aa, Aa, Gg, Gd, Mm, Gs^Vh, Gll^Fp, Wwf, Wwf, Gd, Gd, Xv, Gd, Gd, Wwf, Wwf, Gll^Fp, Gs^Vh, Mm, Gd, Gg, Aa, Aa, Gg
Gg, Gg, Gg, Aa, Gd, Dd^Do, Wwf, Wwf, Gd, Hhd, Gs, Gll^Fp, Xv, Gll^Fp, Gs, Hhd, Gd, Wwf, Wwf, Dd^Do, Gd, Aa, Gg, Gg, Gg
Gg, Gg, Aa, Aa, Gs, Gd, Wwf, Gll^Fp, Hh, Gs, Gs^Vh, Gs, Xv, Gs, Gs^Vh, Gs, Hh, Gll^Fp, Wwf, Gd, Gs, Aa, Aa, Gg, Gg
Gg, 1 Aa, Gg, Gg, Gs, Kh, Gs^Fms, Wwf, Gs, Gs, Gs, Hh, Xv, Hh, Gs, Gs, Gs, Wwf, Gs^Fms, Kh, Gs, Gg, Gg, 3 Aa, Gg
Gg, Aa, Aa, Gg, Gs, Kh, Gs, Wwf, Wwf, Hh, Gll^Fp, Gs, Xv, Gs, Gll^Fp, Hh, Wwf, Wwf, Gs, Kh, Gs, Gg, Aa, Aa, Gg
Xv, Gg, Gg, Aa, Gg, Kh, Gs, Gs, Gs, Wwf, Wwf, Gg^Ve, Xv, Gg^Ve, Wwf, Wwf, Gs, Gs, Gs, Kh, Gg, Aa, Gg, Gg, Xv
Ql, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Ql, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Xv, Ql
Gg, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Xv, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Ql, Gg
"
	name="Afterlife Volcano (big)"
	random_start_time=yes
	turns=-1
	[event]
		first_time_only=no
		name="preload"
		[set_variable]
			name="afterlife_about_header"
			value="Lava comes from below -- walk forward to survive!
"
		[/set_variable]
	[/event]
	[event]
		name="preload"
		[lua]
			code="-- advertisement

local wesnoth = wesnoth
local string = string
local tostring = tostring
local wml = wml
local on_event = wesnoth.require(""lua/on_event.lua"")
local T = wesnoth.require(""lua/helper.lua"").set_wml_tag_metatable {}

local addon_name = tostring((...).name)
local addon_dir = tostring((...).dir)
local addon_about = tostring((...).about)
local addon_icon = tostring((...).icon)
local addon_host_version = tostring((...).version)
addon_icon = string.gsub(addon_icon, ""\n"", """") .. ""~SCALE_INTO(144,144)""

wesnoth.wml_actions.set_menu_item {
	id = ""about_"" .. addon_dir,
	description = ""About: "" .. addon_name,
	synced = false,
	T.command {
		T.message {
			caption = addon_name .. "" v"" .. addon_host_version,
			message = addon_about,
			image = addon_icon
		}
	}
}

local function show_message(text)
	wesnoth.wml_actions.message {
		caption = addon_name,
		message = text,
		image = addon_icon,
	}
end

local filename = ""~add-ons/"" .. addon_dir .. ""/target/version.txt""
local my_version = wesnoth.have_file(filename) and wesnoth.read_file(filename) or ""0.0.0""

local highest_ver_key = ""addon_"" .. addon_dir .. ""_highest""
wml.variables[highest_ver_key] = my_version

on_event(""side turn 1"", function()
	local side_version = wesnoth.synchronize_choice(function() return { v = my_version } end).v
	if rawget(_G, ""print_as_json"") then _G.print_as_json(""addon"", addon_name, wesnoth.current.side, side_version) end

	if wesnoth.compare_versions(side_version, "">"", wml.variables[highest_ver_key]) then
		wml.variables[highest_ver_key] = side_version
	end
end)

if my_version == ""0.0.0"" then
	local text = ""This game uses "" .. addon_name .. "" add-on. ""
		.. ""\n""
		.. ""If you'll like it, feel free to install it from add-ons server.""
		.. ""\n\n""
		.. ""======================\n\n""
		.. addon_about
	show_message(text)
	return
end

on_event(""turn 2"", function()
	if my_version == wml.variables[highest_ver_key] then
		return
	end

	local advertisement = ""ðŸ ‰ðŸ ‰ðŸ ‰ Please upgrade your "" .. addon_name .. "" add-on ðŸ ‰ðŸ ‰ðŸ ‰""
		.. ""\n""
		.. my_version .. "" -> "" .. wml.variables[highest_ver_key]
		.. ""  (you may do that after the game)\n\n""
	show_message(advertisement)
end)


-- "
			[args]
				about="Afterlife -- survival and race maps.

Your units are copied to enemy part of the map to be controlled by AI.
"
				dir="afterlife_scenario"
				icon="misc/blank-hex.png~BLIT(units/human-loyalists/spearman.png~CROP(20,0,31,72)~FL())~BLIT(units/human-loyalists/spearman.png~CROP(20,0,31,72)~GS(),36,0)
"
				name="Afterlife survival"
				version="1.8.1"
			[/args]
		[/lua]
	[/event]
	[time]
		blue=0
		green=-15
		id="dawn"
		image="misc/time-schedules/default/schedule-dawn.png"
#textdomain wesnoth-help
		name=_"Dawn"
		red=-25
		sound="ambient/morning.ogg"
	[/time]
	[time]
		id="morning"
		image="misc/time-schedules/default/schedule-morning.png"
		lawful_bonus=25
		name=_"Morning"
	[/time]
	[time]
		id="afternoon"
		image="misc/time-schedules/default/schedule-afternoon.png"
		lawful_bonus=25
		name=_"Afternoon"
	[/time]
	[time]
		blue=-35
		green=-20
		id="dusk"
		image="misc/time-schedules/default/schedule-dusk.png"
		name=_"Dusk"
		red=10
		sound="ambient/night.ogg"
	[/time]
	[time]
		blue=-13
		green=-45
		id="first_watch"
		image="misc/time-schedules/default/schedule-firstwatch.png"
		lawful_bonus=-25
		name=_"First Watch"
		red=-75
	[/time]
	[time]
		blue=-13
		green=-45
		id="second_watch"
		image="misc/time-schedules/default/schedule-secondwatch.png"
		lawful_bonus=-25
		name=_"Second Watch"
		red=-75
	[/time]
	[music]
		ms_before=12000
		name="knolls.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="wanderer.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="battle.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="transience.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_king_is_dead.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="knalgan_theme.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_city_falls.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="nunc_dimittis.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="revelation.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="loyalists.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="breaking_the_chains.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="elvish-theme.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="legends_of_the_north.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="traveling_minstrels.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="underground.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="vengeful.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="frantic.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_dangerous_symphony.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="heroes_rite.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="suspense.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_deep_path.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="siege_of_laurelmor.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="casualties_of_war.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="silvan_sanctuary.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="battle-epic.ogg"
	[/music]
	[event]
		name="prestart"
		[music]
			ms_before=12000
			name="knolls.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="wanderer.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="battle.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="transience.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_king_is_dead.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="knalgan_theme.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_city_falls.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="nunc_dimittis.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="revelation.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="loyalists.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="breaking_the_chains.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="elvish-theme.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="legends_of_the_north.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="traveling_minstrels.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="underground.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="vengeful.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="frantic.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_dangerous_symphony.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="heroes_rite.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="suspense.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_deep_path.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="siege_of_laurelmor.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="casualties_of_war.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="silvan_sanctuary.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="battle-epic.ogg"
		[/music]
	[/event]
	[event]
		name="preload"
		[lua]
			code="-- json_format

-- wesnoth.dofile(""~add-ons/afterlife_scenario/lua/json_format.lua"")

local next = next
local print = print
local tostring = tostring
local type = type
local gsub = string.gsub
local table = table

local delete_chars = string.char(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31) -- https://www.ietf.org/rfc/rfc4627.txt
local delete_regexp = ""["" .. delete_chars .. ""]""

-- escaping takes 3/4 of the time, but we can't avoid it...
local function escape(str)
	str = gsub(str, delete_regexp, """")
	str = gsub(str, '\\', '\\\\')
	return gsub(str, '""', '\\""')
end

local function print_table_key(obj, buffer)
	local _type = type(obj)
	if _type == ""string"" then
		buffer[#buffer + 1] = escape(obj)
	elseif _type == ""number"" then
		buffer[#buffer + 1] = obj
	elseif _type == ""boolean"" then
		buffer[#buffer + 1] = tostring(obj)
	else
		buffer[#buffer + 1] = '???' .. _type .. '???'
	end
end

local function format_any_value(obj, buffer)
	local _type = type(obj)
	if _type == ""table"" then
		buffer[#buffer + 1] = '{'
		buffer[#buffer + 1] = '""' -- needs to be separate for empty tables {}
		for key, value in next, obj, nil do
			print_table_key(key, buffer)
			buffer[#buffer + 1] = '"":'
			format_any_value(value, buffer)
			buffer[#buffer + 1] = ',""'
		end
		buffer[#buffer] = '}' -- note the overwrite
	elseif _type == ""string"" then
		buffer[#buffer + 1] = '""' .. escape(obj) .. '""'
	elseif _type == ""boolean"" or _type == ""number"" then
		buffer[#buffer + 1] = tostring(obj)
	elseif _type == ""userdata"" then
		buffer[#buffer + 1] = '""' .. escape(tostring(obj)) .. '""'
	else
		buffer[#buffer + 1] = '""???' .. _type .. '???""'
	end
end

local function _format_as_json(obj)
	if obj == nil then return ""null"" else
		local buffer = {}
		format_any_value(obj, buffer)
		return table.concat(buffer)
	end
end

local function _print_as_json(...)
	local result = {}
	local n = 1
	for _, v in ipairs({ ... }) do
		result[n] = _format_as_json(v)
		n = n + 1
	end
	print(table.concat(result, ""\t""))
end


format_as_json = _format_as_json
print_as_json = _print_as_json

-- "
		[/lua]
	[/event]
	[event]
		first_time_only=no
		name="preload"
		[lua]
			code="-- utils_afterlife

afterlife = {}
local afterlife = afterlife
local wesnoth = wesnoth
local ipairs = ipairs
local math = math
local string = string
local table = table
local helper = wesnoth.require(""lua/helper.lua"")
local on_event = wesnoth.require(""lua/on_event.lua"")
local T = wesnoth.require(""lua/helper.lua"").set_wml_tag_metatable {}


wesnoth.wml_conditionals = wesnoth.wml_conditionals or {}
wesnoth.wml_conditionals.has_unit = wesnoth.wml_conditionals.has_unit or function(cfg)
	afterlife.temp = false
	wesnoth.wml_actions[""if""] {
		T.have_unit(cfg),
		T[""then""] { T.lua { code = ""afterlife.temp = true"" } }
	}
	return afterlife.temp
end


local function unit_wml_copy(unit_userdata, x, y)
	wesnoth.wml_actions.store_unit {
		T.filter { id = unit_userdata.id },
		variable = ""afterlife_unit"",
	}
	local unit_var = wesnoth.get_variable(""afterlife_unit"")
	local id = ""afterlife_""
		.. helper.rand(""0..1000000000"")
		.. helper.rand(""0..1000000000"")
		.. helper.rand(""0..1000000000"")
	unit_var.id = id
	unit_var.underlying_id = id
	unit_var.canrecruit = false
	unit_var.x = x
	unit_var.y = y
	wesnoth.set_variable(""afterlife_unit"", unit_var)
	wesnoth.wml_actions.unstore_unit {
		variable = ""afterlife_unit"",
	}
	wesnoth.set_variable(""afterlife_unit"", nil)
	return id
end


local function copy_unit(unit_original, to_pos, to_side, strength_percent)
	if to_pos == nil then return end
	if unit_original.type == ""Fog Clearer"" then return end
	local from_side = unit_original.side
	local new_id = unit_wml_copy(unit_original, to_pos.x, to_pos.y)
	local unit = wesnoth.get_units { id = new_id }[1]
	unit.side = to_side
	unit.status.poisoned = false
	unit.status.slowed = false
	unit.variables.afterlife_fresh_copy = true
	unit.moves = unit.max_moves
	wesnoth.add_modification(unit, ""object"", {
		id = ""afterlife_grayscale"",
		T.effect { apply_to = ""image_mod"", add=""GS()"" },
		T.effect { apply_to = ""zoc"", value = false },
	})
	unit.status.petrified = false
	unit.status.invulnerable = true

	local increase_percent = strength_percent - 100
	local ability = T.name_only {
		name = ""copy"" .. strength_percent ..  ""%"",
		description = strength_percent .. ""% hitpoints, ""
			.. strength_percent .. ""% damage, ""
			.. ""unit copied from side "" .. from_side
	}
	wesnoth.add_modification(unit, ""object"", {
		T.effect { apply_to = ""attack"", increase_damage = increase_percent .. ""%"" },
		T.effect { apply_to = ""hitpoints"", increase_total = increase_percent .. ""%"" },
		T.effect { apply_to = ""new_ability"", T.abilities { ability } },
	})
	unit.hitpoints = unit.max_hitpoints
	wesnoth.set_village_owner(to_pos.x, to_pos.y, to_side, false)
end


local function unpetrify_units()
	local status_filter = ""invulnerable""
	local filtered_units = wesnoth.get_units { side = wesnoth.current.side, status = status_filter }
	for _, unit in ipairs(filtered_units) do
		if unit.variables.afterlife_fresh_copy then
			unit.status.petrified = false
			unit.status.invulnerable = false
			unit.variables.afterlife_fresh_copy = nil
			wesnoth.wml_actions.remove_object {
				id = unit.id,
				object_id = ""afterlife_grayscale"",
			}
			local img = string.gsub(unit.image_mods, ""GS%(%)$"", ""NOP()"", 1)
			wesnoth.add_modification(unit, ""object"", {
				T.effect { apply_to = ""image_mod"", replace = img },
			})
		end
	end
end


local width, height, border = wesnoth.get_map_size()
local half = (width - 1) / 2
local left_edge = border
local left_center = half + border - 1
local right_center = half + border + 1
local right_edge = border + width - 1

local terrain_base_probabilities = {
	[""Gs""] = 4, -- grass
	[""Gd""] = 4, -- grass
	[""Gg""] = 3, -- grass
	[""Wwf""] = 28 , -- ford
	[""Gs^Fms""] = 2, -- forest
	[""Gll^Fp""] = 2, -- forest
	[""Mm""] = 1, -- mountain
	[""Ai""] = 1, -- ice
	[""Hh""] = 2, -- hill
	[""Hhd""] = 2, -- dry hill
	[""Uu^Uf""] = 2, -- mushrooms
	[""Dd^Do""] = 1, -- oasis
	[""Ss""] = 1, -- swamp
	[""Gs^Vh""] = 2, -- village
}
local terrain_variability_multiplier = 1 -- how variable terrain will be
local terrain_iterator = {}
local terrain_total = 0
local function set_probability(terrain_index, value)
	wesnoth.set_variable(""afterlife_terrain_prob_"" .. terrain_index, value)
end
local function get_probability(terrain_index)
	return wesnoth.get_variable(""afterlife_terrain_prob_"" .. terrain_index)
end

for terr, value in pairs(terrain_base_probabilities) do
	-- We will need to sort this later because `pairs` is an unordered (OOS-unsafe) iterator
	terrain_total = terrain_total + value
	terrain_iterator[#terrain_iterator + 1] = terr
end
table.sort(terrain_iterator)
for idx, terr in ipairs(terrain_iterator) do
	if get_probability(idx) == nil then
		local base = terrain_base_probabilities[terr]
		set_probability(idx, base * terrain_variability_multiplier)
	end
end

local function random_terrain()
	local offset = helper.rand(""1.."" .. terrain_total * terrain_variability_multiplier)
	for idx, terrain in ipairs(terrain_iterator) do
		offset = offset - get_probability(idx)
		if offset <= 0 then
			-- Now that this terrain is chosen, decrease the chosen terr probability by total,
			-- and add a distributed base to all terrains
			set_probability(idx, get_probability(idx) - terrain_total)
			for small_idx, small_terrain in ipairs(terrain_iterator) do
				local base = terrain_base_probabilities[small_terrain]
				set_probability(small_idx, get_probability(small_idx) + base)
			end
			return terrain
		end
	end
	return ""Aa^Ecf"" -- snow with fire (to see the error)
end


function afterlife.scroll_terrain_down()
	local castle_length = math.ceil(width / 6)
	local scrolls = wesnoth.get_variable(""afterlife_scrolls"") or 0
	wesnoth.set_variable(""afterlife_scrolls"", scrolls + 1)

	for y = height - 1, border, -1 do
		for x = left_edge, right_edge do
			local upper_terrain = wesnoth.get_terrain(x, y - 1)
			wesnoth.set_terrain(x, y, upper_terrain)
			wesnoth.set_village_owner(x, y, wesnoth.get_village_owner(x, y - 1), false)
		end
	end
	local y = border - 1
	for x = left_edge, left_center do
		local rem = scrolls % (castle_length * 4 - 2)
		local terrain
		if x == left_center and rem >= castle_length * 2 + 1 and rem <= castle_length * 3 then
			terrain = ""Kh""
		elseif x == left_edge and rem >= 2 and rem <= castle_length + 1 then
			terrain = ""Kh""
		else
			terrain = random_terrain()
		end
		wesnoth.set_terrain(x, y, terrain)
		wesnoth.set_terrain(width - x + 1, y, terrain)
	end
end

function afterlife.scroll_units_down()
	for _, unit in ipairs(wesnoth.get_units { y = height }) do
		wesnoth.wml_actions.kill {
			id = unit.id,
			fire_event = true,
			animate = true,
		}
	end
	for y = height - 1, 0, -1 do
		for _, unit in ipairs(wesnoth.get_units { y = y }) do
			unit.y = unit.y + 1
		end
	end
end

function afterlife.schedule_scrolling_down(frequency)
	on_event(""start"", function()
		for _ = height, 0, -1 do
			afterlife.scroll_terrain_down()
		end
		wesnoth.wml_actions.redraw {}
	end)
	on_event(""side turn end"", function()
		local micro_turn = (wesnoth.current.turn - 1) * #wesnoth.sides + wesnoth.current.side - 4
		if micro_turn % frequency == 0 then
			afterlife.scroll_units_down()
			afterlife.scroll_terrain_down()
			wesnoth.wml_actions.redraw {}
		end
	end)
end


function afterlife.find_vacant(unit, y_min, honor_edge, flip)
	y_min = math.max(border, y_min)
	local x_start = unit.x < right_center and right_center or left_center
	local x_end = unit.x < right_center and right_edge or left_edge
	if flip then x_start, x_end = x_end, x_start end
	local x_step = (x_end - x_start) / math.abs(x_end - x_start)
	for y = y_min, height do
		for x = x_start, x_end, x_step do
			local is_edge = honor_edge and y == y_min and x == x_start
			if wesnoth.wml_conditionals.has_unit { x = x, y = y } == false
				and wesnoth.get_terrain(x, y) ~= ""Xv""
				and not is_edge then
				return { x = x, y = y }
			end
		end
	end
end


function afterlife.kill_ai_leaders()
	for _, side in ipairs(wesnoth.sides) do
		if side.__cfg.allow_player == false then
			wesnoth.wml_actions.kill {
				canrecruit = true,
				side = side.side,
				fire_event = false,
				animate = false,
			}
		end
	end
end


local function endlevel_team(winner_team)
	local i_am_winner = false
	for _, side in ipairs(wesnoth.sides) do
		if side.team_name ~= winner_team and side.__cfg.allow_player == true then
			wesnoth.wml_actions.kill {
				side = side.side,
			}
		end
		if side.team_name == winner_team and side.__cfg.allow_player == true and side.is_local then
			i_am_winner = true
		end
	end

	wesnoth.wml_actions.endlevel {
		result = i_am_winner and ""victory"" or ""defeat""
	}
end


print(""active mods:"", wesnoth.game_config.mp_settings.active_mods)


afterlife.endlevel_team = endlevel_team
afterlife.copy_unit = copy_unit
afterlife.unpetrify_units = unpetrify_units

-- "
		[/lua]
		[lua]
			code="-- afterlife/main_defense

local wesnoth = wesnoth
local afterlife = afterlife
local ipairs = ipairs
local math = math
local string = string
local wml = wml
local on_event = wesnoth.require(""lua/on_event.lua"")


local is_team = #wesnoth.sides == 6
local copy_strength_start = is_team and 26 or 32 -- point of no return is about 50%
local copy_strength_increase = 2
local teams = {}
for _, side in ipairs(wesnoth.sides) do
	local team_id = teams[side.team_name] or (#teams + 1);
	teams[side.team_name] = team_id;
	local team = teams[team_id] or { enemy = 3 - team_id, humans = {} };
	teams[team_id] = team
	local is_alive = wml.variables[""afterlife_alive_"" .. side.side] or #wesnoth.get_units { side = side.side } > 0
	wml.variables[""afterlife_alive_"" .. side.side] = is_alive
	if side.__cfg.allow_player == false then
		team.ai = side.side
	elseif is_alive then
		team.humans[#team.humans + 1] = side.side
	end
end
-- print_as_json(teams)


on_event(""start"", function()
	afterlife.kill_ai_leaders()
	for _, side in ipairs(wesnoth.sides) do
		side.village_support = side.village_support + 2
	end
end)

local ai_starting_location_y = wesnoth.get_starting_location(#wesnoth.sides)[2]
local function copy_units(from_side, to_side)
	for _, unit_original in ipairs(wesnoth.get_units { side = from_side }) do
		local percent = copy_strength_start + wesnoth.current.turn * copy_strength_increase
		local to_pos = afterlife.find_vacant(unit_original, ai_starting_location_y, true, is_team)
		if to_pos == nil then
			wesnoth.wml_actions.message {
				speaker = ""narrator"",
				message = ""No free space to place a copy"",
			}
			afterlife.endlevel_team(from_side, wesnoth.sides[from_side].team_name)
			break
		else
			afterlife.copy_unit(unit_original, to_pos, to_side, percent)
		end
	end
end

on_event(""turn refresh"", function()
	local wave_length = wesnoth.get_variable(""afterlife_wave_length"") or 2
	if (wesnoth.current.turn - 1) % wave_length == 0 then
		if wesnoth.current.side == 1 then
			copy_units(teams[1].humans[wesnoth.current.turn % #teams[1].humans + 1], teams[1].ai)
			copy_units(teams[2].humans[wesnoth.current.turn % #teams[2].humans + 1], teams[2].ai)
		end
		if wesnoth.sides[wesnoth.current.side].__cfg.allow_player == false then
			afterlife.unpetrify_units()
		end
	end
	-- print(""turn"", wesnoth.current.turn, ""side"", wesnoth.current.side, ""div"", (wesnoth.current.turn - 2) % wave_length)
	if wave_length > 1 then
		local next_wave_turn = wesnoth.current.turn
			- (wesnoth.current.turn - 2) % wave_length
			+ wave_length - 1
		wesnoth.wml_actions.label {
			x = math.ceil(wesnoth.get_map_size() / 2),
			y = 2,
			text = string.format(""<span color='#FFFFFF'>Next wave:\n    turn %s</span>"", next_wave_turn)
		}
	end
end)

on_event(""side turn end"", function()
	for _, unit in ipairs(wesnoth.get_units { canrecruit = true, side = wesnoth.current.side }) do
		unit.status.uncovered = true
	end
end)


-- "
		[/lua]
		[objectives]
			note="$afterlife_about_header|

Contacts
* Forum: https://forums.wesnoth.org/viewtopic.php?f=8&amp;t=47827
* Source code, issue tracker: https://github.com/vgaming/afterlife
* vasili or vasya: my name on wesnoth :)
* vn971 on IRC.freenode.net (I often visit #wesnoth-umc-dev)


version 1.8.1
"
			[objective]
				condition="win"
#textdomain wesnoth
				description=_"Death of enemy Leader"
			[/objective]
			[objective]
				condition="lose"
				description=_"Death of your Leader"
			[/objective]
		[/objectives]
	[/event]
	[event]
		first_time_only=no
		name="preload"
		[lua]
			code="
				afterlife.schedule_scrolling_down(8)
				wesnoth.set_variable(""afterlife_wave_length"", 3)
			"
		[/lua]
	[/event]
	[side]
		controller="human"
		fog=false
		gold=75
		shroud=false
		team_lock=true
		team_name="West"
	[/side]
	[side]
		allow_player=false
		controller="ai"
		defeat_condition="always"
		fog=false
		shroud=false
		team_lock=true
		team_name="East"
		[ai]
			aggression=0.995
			caution=0.005
			grouping=no
		[/ai]
	[/side]
	[side]
		controller="human"
		fog=false
		gold=75
		shroud=false
		team_lock=true
		team_name="East"
	[/side]
	[side]
		allow_player=false
		controller="ai"
		defeat_condition="always"
		fog=false
		shroud=false
		team_lock=true
		team_name="West"
		[ai]
			aggression=0.995
			caution=0.005
			grouping=no
		[/ai]
	[/side]
[/multiplayer]
[multiplayer]
	description="Waves spawn each time you pass a ___N%___ label.

A wave consists of enemy units copied and controlled by AI. The higher the barrier, the stronger the copies.

Be the first to destroy all waves!
"
	experience_modifier=90
	id="afterlife_race"
	map_data="Xv, Xv, Ai, Ai, Aa, Gg, Gg, Rp, Rp, Xv, Rp, Rp, Gg, Gg, Aa, Ai, Ai, Xv, Xv
Xv, Xv, Ms^Vhh, Ai, Ha, 2 Gg, Gg^Fpa, Aa^Fma, Aa^Fpa, Xv, Aa^Fpa, Aa^Fma, Gg^Fpa, 4 Gg, Ha, Ai, Ms^Vhh, Xv, Xv
Xv, Xv, Aa, Ai, Wwf, Gs, Gs, Ha, Gg, Xv, Gg, Ha, Gs, Gs, Wwf, Ai, Aa, Xv, Xv
Xv, Xv, Hhd, Hhd^Fp, Hh^Fp, Wwf, Wwf, Ds, Mm, Xv, Gg, Ds, Wwf, Wwf, Hh^Fp, Hhd^Fp, Hhd, Xv, Xv
Xv, Xv, Gs, Gg^Uf, Ds, Gs, Wwf, Gg^Uf, Ds, Xv, Ds, Gg^Uf, Wwf, Gs, Ds, Gg^Uf, Gs, Xv, Xv
Xv, Xv, Rrc, Rrc, Ss, Gll^Fdw, Wwf, Hh, Ms, Xv, Ms, Hh, Wwf, Gll^Fdw, Ss, Rrc, Rrc, Xv, Xv
Xv, Xv, Ss, Gg, Wwrg, Wwf, Ds, Gs^Vh, Ha, Xv, Ha, Gs^Vh, Ds, Wwf, Wwrg, Gg, Ss, Xv, Xv
Xv, Xv, Gg, Hh, Wwf, Gll^Fdw, Gg^Uf, Hh, Kha, Xv, Kha, Hh, Gg^Uf, Gll^Fdw, Wwf, Hh, Gg, Xv, Xv
Xv, Xv, Gs, Gg^Efm, Ss, Wwf, Wwf, Dd^Do, Kha, Xv, Kha, Dd^Do, Wwf, Wwf, Ss, Gg^Efm, Gs, Xv, Xv
Xv, Xv, Gll^Fp, Gll^Fp, Gg^Uf, Hhd, Gg, Wwf, Kha, Xv, Kha, Wwf, Gg, Hhd, Gg^Uf, Gll^Fp, Gll^Fp, Xv, Xv
Xv, Xv, Gs, Hh^Vhh, Hh, Mm, Wwf, Wwf, Rp, Xv, Rp, Wwf, Wwf, Mm, Hh, Hh^Vhh, Gs, Xv, Xv
Xv, Xv, Gg, Ss, Wwf, Wwf, Gd, Rp, Gg^Uf, Xv, Gg^Uf, Rp, Gd, Wwf, Wwf, Ss, Gg, Xv, Xv
Xv, Xv, Gg, Hh, Wwf, Gg, Gg^Uf, Ds, Dd^Do, Xv, Dd^Do, Ds, Gg^Uf, Gg, Wwf, Hh, Gg, Xv, Xv
Xv, Xv, Wwf, Wwf, Rrc, Wwf, Wwf, Mm, Ds, Xv, Ds, Mm, Wwf, Wwf, Rrc, Wwf, Wwf, Xv, Xv
Xv, Xv, Wwf, Hh, Dd^Do, Hh, Wwrg, Dd^Vdt, Ds, Xv, Ds, Dd^Vdt, Wwrg, Hh, Dd^Do, Hh, Wwf, Xv, Xv
Xv, Xv, Chw^Kov, Gs, Wwf, Wwf, Gd, Gg^Fp, Gd, Xv, Gd, Gg^Fp, Gd, Wwf, Wwf, Gs, Chw^Kov, Xv, Xv
Xv, Xv, Chw^Kov, Wwf, Hh^Fp, Ds, Hhd, Gg^Efm, Ss, Xv, Ss, Gg^Efm, Hhd, Ds, Hh^Fp, Wwf, Chw^Kov, Xv, Xv
Xv, Xv, Chw^Kov, Hh^Fp, Ds, Gg^Uf, Gd, Dd^Do, Hh, Xv, Hh, Dd^Do, Gd, Gg^Uf, Ds, Hh^Fp, Chw^Kov, Xv, Xv
Xv, Xv, Gs, Wwf, Wwf, Ss, Gg^Fp, Gg^Uf, Ds, Xv, Ds, Gg^Uf, Gg^Fp, Ss, Wwf, Wwf, Gs, Xv, Xv
Xv, Xv, Gg^Uf, Hh^Fp, Ss, Wwf, Wwf, Gg^Fp, Wwf, Xv, Wwf, Gg^Fp, Wwf, Wwf, Ss, Hh^Fp, Gg^Uf, Xv, Xv
Xv, Xv, Gs, Hh, Ss, Gs^Gvs, Wwf, Ww^Vm, Dd^Ftd, Xv, Dd^Ftd, Ww^Vm, Wwf, Gs^Gvs, Ss, Hh, Gs, Xv, Xv
Xv, Xv, Mm, Gg^Uf, Hhd, Ds, Gs, Wwf, Wwf, Xv, Wwf, Wwf, Gs, Ds, Hhd, Gg^Uf, Mm, Xv, Xv
Xv, Xv, Gll^Fdf, Gd, Gs, Dd^Do, Gg^Fdf, Hh, Wwf, Xv, Wwf, Hh, Gg^Fdf, Dd^Do, Gs, Gd, Gll^Fdf, Xv, Xv
Xv, Xv, Gg^Uf, Gg^Fmf, Gg, Gg, Wwf, Wwf, Kh, Xv, Kh, Wwf, Wwf, Gg, Gg, Gg^Fmf, Gg^Uf, Xv, Xv
Xv, Xv, Gg, Hh, Wwf, Wwf, Hh, Gs, Kh, Xv, Kh, Gs, Hh, Wwf, Wwf, Hh, Gg, Xv, Xv
Xv, Xv, Wwf, Hh^Vhh, Wwf, Ss, Rp, Hhd, Kh, Xv, Kh, Hhd, Rp, Ss, Wwf, Hh^Vhh, Wwf, Xv, Xv
Xv, Xv, Gg^Fdf, Wwf, Wwf, Ds, Ss, Hhd, Gd, Xv, Gd, Hhd, Ss, Ds, Wwf, Wwf, Gg^Fdf, Xv, Xv
Xv, Xv, Hh, Gs, Ss, Wwf, Wwf, Ds, Hh^Fdf, Xv, Hh^Fdf, Ds, Wwf, Wwf, Ss, Gs, Hh, Xv, Xv
Xv, Xv, Ss, Hh, Gg^Uf, Gg, Wwf, Gs, Mm, Xv, Mm, Gs, Wwf, Gg, Gg^Uf, Hh, Ss, Xv, Xv
Xv, Xv, Gs, Dd^Do, Wwf, Wwf, Hh, Gs, Rp, Xv, Rp, Gs, Hh, Wwf, Wwf, Dd^Do, Gs, Xv, Xv
Xv, Xv, Hh^Fp, Gs, Wwf, Gg, Hh, Gg^Fms, Gg^Fds, Xv, Gg^Fds, Gg^Fms, Hh, Gg, Wwf, Gs, Hh^Fp, Xv, Xv
Xv, Xv, Kh, Gg, Hh^Fp, Wwrg, Ds, Gg^Ve, Gg^Fds, Xv, Gg^Fds, Gg^Ve, Ds, Wwrg, Hh^Fp, Gg, Kh, Xv, Xv
Xv, Xv, Kh, Gd^Fts, Rp, Wwf, Gd, Gd, Gg^Fms, Xv, Gg^Fms, Gd, Gd, Wwf, Rp, Gd^Fts, Kh, Xv, Xv
Xv, Xv, Kh, Gg, Wwf, Wwf, Hh, Gs, Gs, Xv, Gs, Gs, Hh, Wwf, Wwf, Gg, Kh, Xv, Xv
Xv, Xv, Hh^Fp, Wwf, Gd^Fts, Gd^Fts, Ds, Gd^Fts, Dd^Do, Xv, Dd^Do, Gd^Fts, Ds, Gd^Fts, Gd^Fts, Wwf, Hh^Fp, Xv, Xv
Xv, Xv, Wwf, Wwf, Rp, Gs, Ds, Gd^Fts, Gs, Xv, Gs, Gd^Fts, Ds, Gs, Rp, Wwf, Wwf, Xv, Xv
Xv, Xv, Wwrg, Rp, Gs, Ds, Hhd, Dd^Vda, Dd^Ftd, Xv, Dd^Ftd, Dd^Vda, Hhd, Ds, Gs, Rp, Wwrg, Xv, Xv
Xv, Xv, Wwf, Gg^Ft, Wwf, Hhd, Ds, Gd, Ds, Xv, Ds, Gd, Ds, Hhd, Wwf, Gg^Ft, Wwf, Xv, Xv
Xv, Xv, Gs, Wwf, Mm, Wwf, Wwf, Gd, Hhd, Xv, Hhd, Gd, Wwf, Wwf, Mm, Wwf, Gs, Xv, Xv
Xv, Xv, Hh, Dd^Do, Gs, Ss, Hh, Wwf, 1 Kh, Xv, 3 Kh, Wwf, Hh, Ss, Gs, Dd^Do, Hh, Xv, Xv
Xv, Xv, Ds, Rp, Gs, Gs, Ds, Wwf, Kh, Xv, Kh, Wwf, Ds, Gs, Gs, Rp, Ds, Xv, Xv
Xv, Xv, Gs, Hh^Ft, Wwf, Mm, Wwf, Gs, Gg, Xv, Gs, Gs, Wwf, Mm, Wwf, Hh^Ft, Gs, Xv, Xv
Xv, Xv, Gg, Gs, Rp, Rp, Gg, Gg, Gg, Xv, Gg, Gg, Gg, Rp, Rp, Gs, Gg, Xv, Xv
"
	name="Afterlife Race"
	random_start_time=yes
	turns=-1
	[time]
		blue=0
		green=-15
		id="dawn"
		image="misc/time-schedules/default/schedule-dawn.png"
#textdomain wesnoth-help
		name=_"Dawn"
		red=-25
		sound="ambient/morning.ogg"
	[/time]
	[time]
		id="morning"
		image="misc/time-schedules/default/schedule-morning.png"
		lawful_bonus=25
		name=_"Morning"
	[/time]
	[time]
		id="afternoon"
		image="misc/time-schedules/default/schedule-afternoon.png"
		lawful_bonus=25
		name=_"Afternoon"
	[/time]
	[time]
		blue=-35
		green=-20
		id="dusk"
		image="misc/time-schedules/default/schedule-dusk.png"
		name=_"Dusk"
		red=10
		sound="ambient/night.ogg"
	[/time]
	[time]
		blue=-13
		green=-45
		id="first_watch"
		image="misc/time-schedules/default/schedule-firstwatch.png"
		lawful_bonus=-25
		name=_"First Watch"
		red=-75
	[/time]
	[time]
		blue=-13
		green=-45
		id="second_watch"
		image="misc/time-schedules/default/schedule-secondwatch.png"
		lawful_bonus=-25
		name=_"Second Watch"
		red=-75
	[/time]
	[music]
		ms_before=12000
		name="knolls.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="wanderer.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="battle.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="transience.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_king_is_dead.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="knalgan_theme.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_city_falls.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="nunc_dimittis.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="revelation.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="loyalists.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="breaking_the_chains.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="elvish-theme.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="legends_of_the_north.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="traveling_minstrels.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="underground.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="vengeful.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="frantic.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_dangerous_symphony.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="heroes_rite.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="suspense.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="the_deep_path.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="siege_of_laurelmor.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="casualties_of_war.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="silvan_sanctuary.ogg"
	[/music]
	[music]
		append=yes
		ms_before=12000
		name="battle-epic.ogg"
	[/music]
	[event]
		name="prestart"
		[music]
			ms_before=12000
			name="knolls.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="wanderer.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="battle.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="transience.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_king_is_dead.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="knalgan_theme.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_city_falls.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="nunc_dimittis.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="revelation.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="loyalists.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="breaking_the_chains.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="elvish-theme.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="legends_of_the_north.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="traveling_minstrels.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="underground.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="vengeful.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="frantic.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_dangerous_symphony.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="heroes_rite.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="suspense.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="the_deep_path.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="siege_of_laurelmor.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="casualties_of_war.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="silvan_sanctuary.ogg"
		[/music]
		[music]
			append=yes
			ms_before=12000
			name="battle-epic.ogg"
		[/music]
	[/event]
	[event]
		name="preload"
		[lua]
			code="-- json_format

-- wesnoth.dofile(""~add-ons/afterlife_scenario/lua/json_format.lua"")

local next = next
local print = print
local tostring = tostring
local type = type
local gsub = string.gsub
local table = table

local delete_chars = string.char(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31) -- https://www.ietf.org/rfc/rfc4627.txt
local delete_regexp = ""["" .. delete_chars .. ""]""

-- escaping takes 3/4 of the time, but we can't avoid it...
local function escape(str)
	str = gsub(str, delete_regexp, """")
	str = gsub(str, '\\', '\\\\')
	return gsub(str, '""', '\\""')
end

local function print_table_key(obj, buffer)
	local _type = type(obj)
	if _type == ""string"" then
		buffer[#buffer + 1] = escape(obj)
	elseif _type == ""number"" then
		buffer[#buffer + 1] = obj
	elseif _type == ""boolean"" then
		buffer[#buffer + 1] = tostring(obj)
	else
		buffer[#buffer + 1] = '???' .. _type .. '???'
	end
end

local function format_any_value(obj, buffer)
	local _type = type(obj)
	if _type == ""table"" then
		buffer[#buffer + 1] = '{'
		buffer[#buffer + 1] = '""' -- needs to be separate for empty tables {}
		for key, value in next, obj, nil do
			print_table_key(key, buffer)
			buffer[#buffer + 1] = '"":'
			format_any_value(value, buffer)
			buffer[#buffer + 1] = ',""'
		end
		buffer[#buffer] = '}' -- note the overwrite
	elseif _type == ""string"" then
		buffer[#buffer + 1] = '""' .. escape(obj) .. '""'
	elseif _type == ""boolean"" or _type == ""number"" then
		buffer[#buffer + 1] = tostring(obj)
	elseif _type == ""userdata"" then
		buffer[#buffer + 1] = '""' .. escape(tostring(obj)) .. '""'
	else
		buffer[#buffer + 1] = '""???' .. _type .. '???""'
	end
end

local function _format_as_json(obj)
	if obj == nil then return ""null"" else
		local buffer = {}
		format_any_value(obj, buffer)
		return table.concat(buffer)
	end
end

local function _print_as_json(...)
	local result = {}
	local n = 1
	for _, v in ipairs({ ... }) do
		result[n] = _format_as_json(v)
		n = n + 1
	end
	print(table.concat(result, ""\t""))
end


format_as_json = _format_as_json
print_as_json = _print_as_json

-- "
		[/lua]
	[/event]
	[event]
		first_time_only=no
		name="preload"
		[lua]
			code="-- utils_afterlife

afterlife = {}
local afterlife = afterlife
local wesnoth = wesnoth
local ipairs = ipairs
local math = math
local string = string
local table = table
local helper = wesnoth.require(""lua/helper.lua"")
local on_event = wesnoth.require(""lua/on_event.lua"")
local T = wesnoth.require(""lua/helper.lua"").set_wml_tag_metatable {}


wesnoth.wml_conditionals = wesnoth.wml_conditionals or {}
wesnoth.wml_conditionals.has_unit = wesnoth.wml_conditionals.has_unit or function(cfg)
	afterlife.temp = false
	wesnoth.wml_actions[""if""] {
		T.have_unit(cfg),
		T[""then""] { T.lua { code = ""afterlife.temp = true"" } }
	}
	return afterlife.temp
end


local function unit_wml_copy(unit_userdata, x, y)
	wesnoth.wml_actions.store_unit {
		T.filter { id = unit_userdata.id },
		variable = ""afterlife_unit"",
	}
	local unit_var = wesnoth.get_variable(""afterlife_unit"")
	local id = ""afterlife_""
		.. helper.rand(""0..1000000000"")
		.. helper.rand(""0..1000000000"")
		.. helper.rand(""0..1000000000"")
	unit_var.id = id
	unit_var.underlying_id = id
	unit_var.canrecruit = false
	unit_var.x = x
	unit_var.y = y
	wesnoth.set_variable(""afterlife_unit"", unit_var)
	wesnoth.wml_actions.unstore_unit {
		variable = ""afterlife_unit"",
	}
	wesnoth.set_variable(""afterlife_unit"", nil)
	return id
end


local function copy_unit(unit_original, to_pos, to_side, strength_percent)
	if to_pos == nil then return end
	if unit_original.type == ""Fog Clearer"" then return end
	local from_side = unit_original.side
	local new_id = unit_wml_copy(unit_original, to_pos.x, to_pos.y)
	local unit = wesnoth.get_units { id = new_id }[1]
	unit.side = to_side
	unit.status.poisoned = false
	unit.status.slowed = false
	unit.variables.afterlife_fresh_copy = true
	unit.moves = unit.max_moves
	wesnoth.add_modification(unit, ""object"", {
		id = ""afterlife_grayscale"",
		T.effect { apply_to = ""image_mod"", add=""GS()"" },
		T.effect { apply_to = ""zoc"", value = false },
	})
	unit.status.petrified = false
	unit.status.invulnerable = true

	local increase_percent = strength_percent - 100
	local ability = T.name_only {
		name = ""copy"" .. strength_percent ..  ""%"",
		description = strength_percent .. ""% hitpoints, ""
			.. strength_percent .. ""% damage, ""
			.. ""unit copied from side "" .. from_side
	}
	wesnoth.add_modification(unit, ""object"", {
		T.effect { apply_to = ""attack"", increase_damage = increase_percent .. ""%"" },
		T.effect { apply_to = ""hitpoints"", increase_total = increase_percent .. ""%"" },
		T.effect { apply_to = ""new_ability"", T.abilities { ability } },
	})
	unit.hitpoints = unit.max_hitpoints
	wesnoth.set_village_owner(to_pos.x, to_pos.y, to_side, false)
end


local function unpetrify_units()
	local status_filter = ""invulnerable""
	local filtered_units = wesnoth.get_units { side = wesnoth.current.side, status = status_filter }
	for _, unit in ipairs(filtered_units) do
		if unit.variables.afterlife_fresh_copy then
			unit.status.petrified = false
			unit.status.invulnerable = false
			unit.variables.afterlife_fresh_copy = nil
			wesnoth.wml_actions.remove_object {
				id = unit.id,
				object_id = ""afterlife_grayscale"",
			}
			local img = string.gsub(unit.image_mods, ""GS%(%)$"", ""NOP()"", 1)
			wesnoth.add_modification(unit, ""object"", {
				T.effect { apply_to = ""image_mod"", replace = img },
			})
		end
	end
end


local width, height, border = wesnoth.get_map_size()
local half = (width - 1) / 2
local left_edge = border
local left_center = half + border - 1
local right_center = half + border + 1
local right_edge = border + width - 1

local terrain_base_probabilities = {
	[""Gs""] = 4, -- grass
	[""Gd""] = 4, -- grass
	[""Gg""] = 3, -- grass
	[""Wwf""] = 28 , -- ford
	[""Gs^Fms""] = 2, -- forest
	[""Gll^Fp""] = 2, -- forest
	[""Mm""] = 1, -- mountain
	[""Ai""] = 1, -- ice
	[""Hh""] = 2, -- hill
	[""Hhd""] = 2, -- dry hill
	[""Uu^Uf""] = 2, -- mushrooms
	[""Dd^Do""] = 1, -- oasis
	[""Ss""] = 1, -- swamp
	[""Gs^Vh""] = 2, -- village
}
local terrain_variability_multiplier = 1 -- how variable terrain will be
local terrain_iterator = {}
local terrain_total = 0
local function set_probability(terrain_index, value)
	wesnoth.set_variable(""afterlife_terrain_prob_"" .. terrain_index, value)
end
local function get_probability(terrain_index)
	return wesnoth.get_variable(""afterlife_terrain_prob_"" .. terrain_index)
end

for terr, value in pairs(terrain_base_probabilities) do
	-- We will need to sort this later because `pairs` is an unordered (OOS-unsafe) iterator
	terrain_total = terrain_total + value
	terrain_iterator[#terrain_iterator + 1] = terr
end
table.sort(terrain_iterator)
for idx, terr in ipairs(terrain_iterator) do
	if get_probability(idx) == nil then
		local base = terrain_base_probabilities[terr]
		set_probability(idx, base * terrain_variability_multiplier)
	end
end

local function random_terrain()
	local offset = helper.rand(""1.."" .. terrain_total * terrain_variability_multiplier)
	for idx, terrain in ipairs(terrain_iterator) do
		offset = offset - get_probability(idx)
		if offset <= 0 then
			-- Now that this terrain is chosen, decrease the chosen terr probability by total,
			-- and add a distributed base to all terrains
			set_probability(idx, get_probability(idx) - terrain_total)
			for small_idx, small_terrain in ipairs(terrain_iterator) do
				local base = terrain_base_probabilities[small_terrain]
				set_probability(small_idx, get_probability(small_idx) + base)
			end
			return terrain
		end
	end
	return ""Aa^Ecf"" -- snow with fire (to see the error)
end


function afterlife.scroll_terrain_down()
	local castle_length = math.ceil(width / 6)
	local scrolls = wesnoth.get_variable(""afterlife_scrolls"") or 0
	wesnoth.set_variable(""afterlife_scrolls"", scrolls + 1)

	for y = height - 1, border, -1 do
		for x = left_edge, right_edge do
			local upper_terrain = wesnoth.get_terrain(x, y - 1)
			wesnoth.set_terrain(x, y, upper_terrain)
			wesnoth.set_village_owner(x, y, wesnoth.get_village_owner(x, y - 1), false)
		end
	end
	local y = border - 1
	for x = left_edge, left_center do
		local rem = scrolls % (castle_length * 4 - 2)
		local terrain
		if x == left_center and rem >= castle_length * 2 + 1 and rem <= castle_length * 3 then
			terrain = ""Kh""
		elseif x == left_edge and rem >= 2 and rem <= castle_length + 1 then
			terrain = ""Kh""
		else
			terrain = random_terrain()
		end
		wesnoth.set_terrain(x, y, terrain)
		wesnoth.set_terrain(width - x + 1, y, terrain)
	end
end

function afterlife.scroll_units_down()
	for _, unit in ipairs(wesnoth.get_units { y = height }) do
		wesnoth.wml_actions.kill {
			id = unit.id,
			fire_event = true,
			animate = true,
		}
	end
	for y = height - 1, 0, -1 do
		for _, unit in ipairs(wesnoth.get_units { y = y }) do
			unit.y = unit.y + 1
		end
	end
end

function afterlife.schedule_scrolling_down(frequency)
	on_event(""start"", function()
		for _ = height, 0, -1 do
			afterlife.scroll_terrain_down()
		end
		wesnoth.wml_actions.redraw {}
	end)
	on_event(""side turn end"", function()
		local micro_turn = (wesnoth.current.turn - 1) * #wesnoth.sides + wesnoth.current.side - 4
		if micro_turn % frequency == 0 then
			afterlife.scroll_units_down()
			afterlife.scroll_terrain_down()
			wesnoth.wml_actions.redraw {}
		end
	end)
end


function afterlife.find_vacant(unit, y_min, honor_edge, flip)
	y_min = math.max(border, y_min)
	local x_start = unit.x < right_center and right_center or left_center
	local x_end = unit.x < right_center and right_edge or left_edge
	if flip then x_start, x_end = x_end, x_start end
	local x_step = (x_end - x_start) / math.abs(x_end - x_start)
	for y = y_min, height do
		for x = x_start, x_end, x_step do
			local is_edge = honor_edge and y == y_min and x == x_start
			if wesnoth.wml_conditionals.has_unit { x = x, y = y } == false
				and wesnoth.get_terrain(x, y) ~= ""Xv""
				and not is_edge then
				return { x = x, y = y }
			end
		end
	end
end


function afterlife.kill_ai_leaders()
	for _, side in ipairs(wesnoth.sides) do
		if side.__cfg.allow_player == false then
			wesnoth.wml_actions.kill {
				canrecruit = true,
				side = side.side,
				fire_event = false,
				animate = false,
			}
		end
	end
end


local function endlevel_team(winner_team)
	local i_am_winner = false
	for _, side in ipairs(wesnoth.sides) do
		if side.team_name ~= winner_team and side.__cfg.allow_player == true then
			wesnoth.wml_actions.kill {
				side = side.side,
			}
		end
		if side.team_name == winner_team and side.__cfg.allow_player == true and side.is_local then
			i_am_winner = true
		end
	end

	wesnoth.wml_actions.endlevel {
		result = i_am_winner and ""victory"" or ""defeat""
	}
end


print(""active mods:"", wesnoth.game_config.mp_settings.active_mods)


afterlife.endlevel_team = endlevel_team
afterlife.copy_unit = copy_unit
afterlife.unpetrify_units = unpetrify_units

-- "
		[/lua]
		[lua]
			code="-- afterlife_main

local wesnoth = wesnoth
local afterlife = afterlife
local ipairs = ipairs
local math = math
local table = table
local on_event = wesnoth.require(""lua/on_event.lua"")
local T = wesnoth.require(""lua/helper.lua"").set_wml_tag_metatable {}


local human_side1, human_side2 = 1, 3
local sides = {
	[1] = { enemy_human = 3, enemy_ai = 2, half_owner = 1 },
	[2] = { half_owner = 1 },
	[3] = { enemy_human = 1, enemy_ai = 4, half_owner = 3 },
	[4] = { half_owner = 2 },
}

wesnoth.wml_actions.event {
	name = ""turn refresh"",
	first_time_only = false,
	T.lua { code = ""afterlife.turn_refresh_event()"" }
}
wesnoth.wml_actions.event {
	name = ""die"",
	first_time_only = false,
	T.lua { code = ""afterlife.die_event()"" }
}
wesnoth.wml_actions.event {
	name = ""prestart"",
	first_time_only = false,
	T.lua { code = ""afterlife.prestart_event()"" }
}

local waves = {}
local wave_count = wesnoth.get_variable(""afterlife_wave_count_"") -- added a trailing _ to reset settings
	or 12 -- also change default in WML
for _, side in ipairs(wesnoth.sides) do
	local diff = (wave_count < 7 and 2) or (wave_count < 10 and 1) or 0
	side.village_gold = side.village_gold + diff
	side.village_support = side.village_support + diff
end
for idx = 0, wave_count - 1 do
	local step = wave_count > 12 and 35 / (wave_count - 1) or 35 / 11
	local y = math.floor(41 - idx * step + 0.5)
	waves[#waves + 1] = { y = y }
end
waves.strength = function(idx) return math.floor(40 + 30 * (idx - 1) / (#waves - 1) + 0.5) end

local width, height, border = wesnoth.get_map_size()
local left_label, right_label = border + math.floor(width * 1 / 4), border + math.floor(width * 3 / 4)


local function copy_units(from_side, to_side, copy_strength, y_min)
	--print(""generating wave"", from_side, to_side, copy_strength, y_min)
	for _, unit_original in ipairs(wesnoth.get_units { side = from_side }) do
		local to_pos = afterlife.find_vacant(unit_original, y_min)
		afterlife.copy_unit(unit_original, to_pos, to_side, copy_strength)
	end
end


local function generate_wave(side)
	local prev_distance = wesnoth.get_variable(""afterlife_distance_"" .. side) or height + 1
	local units = wesnoth.get_units { side = side }
	table.sort(units, function(a, b) return a.y > b.y end)
	local new_distance = math.min(prev_distance, units[#units].y)
	wesnoth.set_variable(""afterlife_distance_"" .. side, new_distance)
	--print(""side"", side, ""distance"", new_distance)
	for idx, wave_info in ipairs(waves) do
		if new_distance <= wave_info.y and prev_distance > wave_info.y then
			(wesnoth.label or wesnoth.wml_actions.label) {
				x = side == human_side1 and left_label or right_label,
				y = wave_info.y,
				text = """",
			}
			copy_units(sides[side].enemy_human, sides[side].enemy_ai, waves.strength(idx), wave_info.y - 7)
		end
	end
end


local function check_win(side)
	if (side == human_side1 or side == human_side2)
		and wesnoth.get_variable(""afterlife_distance_"" .. side) <= waves[#waves].y
		and not wesnoth.wml_conditionals.has_unit { side = sides[side].enemy_ai } then
		afterlife.endlevel_team(wesnoth.sides[side].team_name)
	end
end


local function green_to_red(frac)
	local red = math.min(255, math.ceil(frac * 2 * 255))
	local green = math.min(255, math.ceil(255 * 2 - frac * 2 * 255))
	return { red, green, 0, 255 }
end


function afterlife.prestart_event()
	for _, side in ipairs(wesnoth.sides) do
		side.village_support = side.village_support + 1
	end
	afterlife.kill_ai_leaders()
	for wave_index, wave_info in ipairs(waves) do
		for _, x in ipairs { left_label, right_label } do
			(wesnoth.label or wesnoth.wml_actions.label) {
				x = x,
				y = wave_info.y,
				color = green_to_red(wave_index / #waves),
				text = ""____"" .. waves.strength(wave_index) .. ""%____"",
			}
		end
	end
end


local function turn_refresh_event()
	if wesnoth.current.side == 1 then
		generate_wave(human_side1)
		generate_wave(human_side2)
	end
	if wesnoth.current.side == human_side2 then
		check_win(human_side1)
	end
	if wesnoth.current.side == human_side1 then
		check_win(human_side2)
	end
	afterlife.unpetrify_units()
end


function afterlife.die_event()
	--print(""die event"", wesnoth.current.side, sides[wesnoth.current.side].half_owner)
	check_win(sides[wesnoth.current.side].half_owner)
end


on_event(""start"", function()
	for _ = 0, 46 do
		afterlife.scroll_terrain_down()
	end
	wesnoth.wml_actions.redraw {}
end)
afterlife.turn_refresh_event = turn_refresh_event

-- "
		[/lua]
		[objectives]
			note="
<b>Rules</b>
Waves spawn each time you pass a ___N%___ label.

A wave consists of enemy units copied and controlled by AI. The higher the barrier, the stronger the copies.

Be the first to destroy all waves!


<b>Contacts</b>
* Forum: https://forums.wesnoth.org/viewtopic.php?f=8&amp;t=47827
* Source code, issue tracker: https://github.com/vgaming/afterlife
* vasili or vasya: my name on wesnoth :)
* vn971 on IRC.freenode.net (I often visit #wesnoth-umc-dev)


version 1.8.1
"
			[objective]
				condition="win"
				description="Be the first to destroy all waves."
			[/objective]
			[objective]
				condition="lose"
				description="Enemy side destroys all waves first."
			[/objective]
		[/objectives]
	[/event]
	[options]
		[slider]
			default=5
			id="afterlife_wave_count_"
			max=15
			min=4
			name="Wave count
4-6 waves: beginner
7-9 waves: intermediate
10+ waves: pro"
			step=1
		[/slider]
	[/options]
	[event]
		name="preload"
		[lua]
			code="-- advertisement

local wesnoth = wesnoth
local string = string
local tostring = tostring
local wml = wml
local on_event = wesnoth.require(""lua/on_event.lua"")
local T = wesnoth.require(""lua/helper.lua"").set_wml_tag_metatable {}

local addon_name = tostring((...).name)
local addon_dir = tostring((...).dir)
local addon_about = tostring((...).about)
local addon_icon = tostring((...).icon)
local addon_host_version = tostring((...).version)
addon_icon = string.gsub(addon_icon, ""\n"", """") .. ""~SCALE_INTO(144,144)""

wesnoth.wml_actions.set_menu_item {
	id = ""about_"" .. addon_dir,
	description = ""About: "" .. addon_name,
	synced = false,
	T.command {
		T.message {
			caption = addon_name .. "" v"" .. addon_host_version,
			message = addon_about,
			image = addon_icon
		}
	}
}

local function show_message(text)
	wesnoth.wml_actions.message {
		caption = addon_name,
		message = text,
		image = addon_icon,
	}
end

local filename = ""~add-ons/"" .. addon_dir .. ""/target/version.txt""
local my_version = wesnoth.have_file(filename) and wesnoth.read_file(filename) or ""0.0.0""

local highest_ver_key = ""addon_"" .. addon_dir .. ""_highest""
wml.variables[highest_ver_key] = my_version

on_event(""side turn 1"", function()
	local side_version = wesnoth.synchronize_choice(function() return { v = my_version } end).v
	if rawget(_G, ""print_as_json"") then _G.print_as_json(""addon"", addon_name, wesnoth.current.side, side_version) end

	if wesnoth.compare_versions(side_version, "">"", wml.variables[highest_ver_key]) then
		wml.variables[highest_ver_key] = side_version
	end
end)

if my_version == ""0.0.0"" then
	local text = ""This game uses "" .. addon_name .. "" add-on. ""
		.. ""\n""
		.. ""If you'll like it, feel free to install it from add-ons server.""
		.. ""\n\n""
		.. ""======================\n\n""
		.. addon_about
	show_message(text)
	return
end

on_event(""turn 2"", function()
	if my_version == wml.variables[highest_ver_key] then
		return
	end

	local advertisement = ""ðŸ ‰ðŸ ‰ðŸ ‰ Please upgrade your "" .. addon_name .. "" add-on ðŸ ‰ðŸ ‰ðŸ ‰""
		.. ""\n""
		.. my_version .. "" -> "" .. wml.variables[highest_ver_key]
		.. ""  (you may do that after the game)\n\n""
	show_message(advertisement)
end)


-- "
			[args]
				about="Afterlife -- survival and race maps.

Your units are copied to enemy part of the map to be controlled by AI.
"
				dir="afterlife_scenario"
				icon="misc/blank-hex.png~BLIT(units/human-loyalists/spearman.png~CROP(20,0,31,72)~FL())~BLIT(units/human-loyalists/spearman.png~CROP(20,0,31,72)~GS(),36,0)
"
				name="Afterlife survival"
				version="1.8.1"
			[/args]
		[/lua]
	[/event]
	[side]
		controller="human"
		fog=false
		gold=75
		shroud=false
		team_lock=true
		team_name="West"
	[/side]
	[side]
		allow_player=false
		controller="ai"
		defeat_condition="always"
		fog=false
		shroud=false
		team_lock=true
		team_name="East"
		[ai]
			aggression=0.995
			caution=0.005
			grouping=no
		[/ai]
	[/side]
	[side]
		controller="human"
		fog=false
		gold=75
		shroud=false
		team_lock=true
		team_name="East"
	[/side]
	[side]
		allow_player=false
		controller="ai"
		defeat_condition="always"
		fog=false
		shroud=false
		team_lock=true
		team_name="West"
		[ai]
			aggression=0.995
			caution=0.005
			grouping=no
		[/ai]
	[/side]
[/multiplayer]
